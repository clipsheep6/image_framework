diff --git a/frameworks/innerkitsimpl/common/src/pixel_map.cpp b/frameworks/innerkitsimpl/common/src/pixel_map.cpp
index 5315c388dc26ddd232f60159e0b565d506e427d3..0b214de542a5950a98888a0112943fbcb2145eab 100644
--- a/frameworks/innerkitsimpl/common/src/pixel_map.cpp
+++ b/frameworks/innerkitsimpl/common/src/pixel_map.cpp
@@ -34,6 +34,7 @@
 #include "post_proc.h"
 #include "parcel.h"
 #include "pubdef.h"
+#include "image_mdk_common.h"
 
 #ifndef _WIN32
 #include "securec.h"
@@ -217,14 +218,22 @@ unique_ptr<PixelMap> PixelMap::Create(const uint32_t *colors, uint32_t colorLeng
 
 unique_ptr<PixelMap> PixelMap::Create(const uint32_t *colors, uint32_t colorLength, int32_t offset, int32_t stride,
                                       const InitializationOptions &opts, bool useCustomFormat)
+{
+    int errorCode;
+    return Create(colors, colorLength, 0, opts.size.width, opts, false, errorCode);
+}
+
+unique_ptr<PixelMap> PixelMap::Create(const uint32_t *colors, uint32_t colorLength, int32_t offset, int32_t stride,
+                                      const InitializationOptions &opts, bool useCustomFormat, int32_t &errorCode)
 {
     HiLog::Info(LABEL, "PixelMap::Create useCustomFormat enter");
-    if (!CheckParams(colors, colorLength, offset, stride, opts)) {
+    if (!CheckParams(colors, colorLength, offset, stride, opts, errorCode)) {
         return nullptr;
     }
     unique_ptr<PixelMap> dstPixelMap = make_unique<PixelMap>();
     if (dstPixelMap == nullptr) {
         HiLog::Error(LABEL, "create pixelMap pointer fail");
+        errorCode = IMAGE_RESULT_PLUGIN_REGISTER_FAILED;
         return nullptr;
     }
 
@@ -241,6 +250,7 @@ unique_ptr<PixelMap> PixelMap::Create(const uint32_t *colors, uint32_t colorLeng
     ImageInfo dstImageInfo = MakeImageInfo(opts.size.width, opts.size.height, dstPixelFormat, dstAlphaType);
     if (!CheckPixelmap(dstPixelMap, dstImageInfo)) {
         HiLog::Error(LABEL, "check pixelMap pointer fail");
+        errorCode = IMAGE_RESULT_ENCODE_FAILED;
         return nullptr;
     }
     int fd = 0;
@@ -248,6 +258,7 @@ unique_ptr<PixelMap> PixelMap::Create(const uint32_t *colors, uint32_t colorLeng
     void *dstPixels = AllocSharedMemory(bufferSize, fd, dstPixelMap->GetUniqueId());
     if (dstPixels == nullptr) {
         HiLog::Error(LABEL, "allocate memory size %{public}u fail", bufferSize);
+        errorCode = IMAGE_RESULT_ERR_SHAMEM_NOT_EXIST;
         return nullptr;
     }
 
@@ -259,6 +270,7 @@ unique_ptr<PixelMap> PixelMap::Create(const uint32_t *colors, uint32_t colorLeng
         HiLog::Error(LABEL, "pixel convert in adapter failed.");
         ReleaseBuffer(AllocatorType::SHARE_MEM_ALLOC, fd, bufferSize, &dstPixels);
         dstPixels = nullptr;
+        errorCode = IMAGE_RESULT_THIRDPART_SKIA_ERROR;
         return nullptr;
     }
 
@@ -323,30 +335,42 @@ void *PixelMap::AllocSharedMemory(const uint64_t bufferSize, int &fd, uint32_t u
 }
 
 bool PixelMap::CheckParams(const uint32_t *colors, uint32_t colorLength, int32_t offset, int32_t stride,
-                           const InitializationOptions &opts)
+    const InitializationOptions &opts)
+{
+    int error;
+    return CheckParams(colors, colorLength, offset, stride, opts, error);
+}
+
+bool PixelMap::CheckParams(const uint32_t *colors, uint32_t colorLength, int32_t offset, int32_t stride,
+    const InitializationOptions &opts, int &error)
 {
     if (colors == nullptr || colorLength <= 0 || colorLength > PIXEL_MAP_MAX_RAM_SIZE) {
         HiLog::Error(LABEL, "colors invalid");
+        error = IMAGE_RESULT_INIT_ABNORMAL;
         return false;
     }
     int32_t dstWidth = opts.size.width;
     int32_t dstHeight = opts.size.height;
     if (dstWidth <= 0 || dstHeight <= 0) {
         HiLog::Error(LABEL, "initial options size invalid");
+        error = IMAGE_RESULT_DATA_ABNORMAL;
         return false;
     }
     if (stride < dstWidth) {
         HiLog::Error(LABEL, "stride: %{public}d must >= width: %{public}d", stride, dstWidth);
+        error = IMAGE_RESULT_GET_DATA_ABNORMAL;
         return false;
     }
     if (stride > MAX_DIMENSION) {
         HiLog::Error(LABEL, "stride %{public}d is out of range", stride);
+        error = IMAGE_RESULT_DATA_UNSUPPORT;
         return false;
     }
     int64_t lastLine = static_cast<int64_t>(dstHeight - 1) * stride + offset;
     if (offset < 0 || static_cast<int64_t>(offset) + dstWidth > colorLength || lastLine + dstWidth > colorLength) {
         HiLog::Error(LABEL, "colors length: %{public}u, offset: %{public}d, stride: %{public}d  is invalid",
                      colorLength, offset, stride);
+        error = IMAGE_RESULT_DECODE_HEAD_ABNORMAL;
         return false;
     }
     return true;
@@ -424,6 +448,13 @@ unique_ptr<PixelMap> PixelMap::Create(PixelMap &source, const InitializationOpti
 }
 
 unique_ptr<PixelMap> PixelMap::Create(PixelMap &source, const Rect &srcRect, const InitializationOptions &opts)
+{
+    int error;
+    return Create(source, srcRect, opts, error);
+}
+
+unique_ptr<PixelMap> PixelMap::Create(PixelMap &source, const Rect &srcRect, const InitializationOptions &opts,
+    int32_t &errorCode)
 {
     HiLog::Info(LABEL, "PixelMap::Create5 enter");
     ImageInfo srcImageInfo;
@@ -433,6 +464,7 @@ unique_ptr<PixelMap> PixelMap::Create(PixelMap &source, const Rect &srcRect, con
     CropValue cropType = PostProc::ValidCropValue(sRect, srcImageInfo.size);
     if (cropType == CropValue::INVALID) {
         HiLog::Error(LABEL, "src crop range is invalid");
+        errorCode = IMAGE_RESULT_DECODE_FAILED;
         return nullptr;
     }
     ImageInfo dstImageInfo;
@@ -448,6 +480,7 @@ unique_ptr<PixelMap> PixelMap::Create(PixelMap &source, const Rect &srcRect, con
     unique_ptr<PixelMap> dstPixelMap = make_unique<PixelMap>();
     if (dstPixelMap == nullptr) {
         HiLog::Error(LABEL, "create pixelmap pointer fail");
+        errorCode = IMAGE_RESULT_PLUGIN_REGISTER_FAILED;
         return nullptr;
     }
     if (cropType == CropValue::VALID) {
@@ -457,16 +490,17 @@ unique_ptr<PixelMap> PixelMap::Create(PixelMap &source, const Rect &srcRect, con
         dstImageInfo.size = srcImageInfo.size;
     }
     if (dstPixelMap->SetImageInfo(dstImageInfo) != SUCCESS) {
+        errorCode = IMAGE_RESULT_DATA_ABNORMAL;
         return nullptr;
     }
     // dst pixelmap is source crop and convert pixelmap
     if ((cropType == CropValue::VALID) || isHasConvert) {
-        if (!SourceCropAndConvert(source, srcImageInfo, dstImageInfo, sRect, *dstPixelMap.get())) {
+        if (!SourceCropAndConvert(source, srcImageInfo, dstImageInfo, sRect, *dstPixelMap.get(), errorCode)) {
             return nullptr;
         }
     } else {
         // only maybe size changed, copy source as scale operation
-        if (!CopyPixelMap(source, *dstPixelMap.get())) {
+        if (!CopyPixelMap(source, *dstPixelMap.get(), errorCode)) {
             return nullptr;
         }
     }
@@ -478,11 +512,19 @@ unique_ptr<PixelMap> PixelMap::Create(PixelMap &source, const Rect &srcRect, con
 }
 
 bool PixelMap::SourceCropAndConvert(PixelMap &source, const ImageInfo &srcImageInfo, const ImageInfo &dstImageInfo,
-                                    const Rect &srcRect, PixelMap &dstPixelMap)
+    const Rect &srcRect, PixelMap &dstPixelMap, int &error)
+{
+    int error;
+    return SourceCropAndConvert(source, srcImageInfo, dstImageInfo, srcRect, dstPixelMap, error);
+}
+
+bool PixelMap::SourceCropAndConvert(PixelMap &source, const ImageInfo &srcImageInfo, const ImageInfo &dstImageInfo,
+    const Rect &srcRect, PixelMap &dstPixelMap, int &error)
 {
     uint32_t bufferSize = dstPixelMap.GetByteCount();
     if (bufferSize == 0 || bufferSize > PIXEL_MAP_MAX_RAM_SIZE) {
         HiLog::Error(LABEL, "AllocSharedMemory  parameter bufferSize:[%{public}d] error.", bufferSize);
+        error = IMAGE_RESULT_DATA_ABNORMAL;
         return false;
     }
     int fd = 0;
@@ -494,6 +536,7 @@ bool PixelMap::SourceCropAndConvert(PixelMap &source, const ImageInfo &srcImageI
     }
     if (dstPixels == nullptr) {
         HiLog::Error(LABEL, "source crop allocate memory fail allocatetype: %{public}d ", source.GetAllocatorType());
+        error = IMAGE_RESULT_ERR_SHAMEM_DATA_ABNORMAL;
         return false;
     }
 
@@ -505,6 +548,7 @@ bool PixelMap::SourceCropAndConvert(PixelMap &source, const ImageInfo &srcImageI
         dstPixels, dstPixelMap.GetRowStride(), dstImageInfo)) {
         HiLog::Error(LABEL, "pixel convert in adapter failed.");
         ReleaseBuffer(fd > 0 ? AllocatorType::SHARE_MEM_ALLOC : AllocatorType::HEAP_ALLOC, fd, bufferSize, &dstPixels);
+        error = IMAGE_RESULT_THIRDPART_SKIA_ERROR;
         return false;
     }
 
@@ -589,14 +633,21 @@ bool PixelMap::CopyPixMapToDst(PixelMap &source, void* &dstPixels, int &fd, uint
 }
 
 bool PixelMap::CopyPixelMap(PixelMap &source, PixelMap &dstPixelMap)
+{
+    int32_t error;
+    return CopyPixelMap(source, dstPixelMap, error);
+}
+bool PixelMap::CopyPixelMap(PixelMap &source, PixelMap &dstPixelMap, int32_t &error)
 {
     uint32_t bufferSize = source.GetByteCount();
     if (source.GetPixels() == nullptr) {
         HiLog::Error(LABEL, "source pixelMap data invalid");
+        error = IMAGE_RESULT_GET_DATA_ABNORMAL;
         return false;
     }
     if (bufferSize == 0 || bufferSize > PIXEL_MAP_MAX_RAM_SIZE) {
         HiLog::Error(LABEL, "AllocSharedMemory parameter bufferSize:[%{public}d] error.", bufferSize);
+        error = IMAGE_RESULT_DATA_ABNORMAL;
         return false;
     }
     int fd = 0;
@@ -608,10 +659,12 @@ bool PixelMap::CopyPixelMap(PixelMap &source, PixelMap &dstPixelMap)
     }
     if (dstPixels == nullptr) {
         HiLog::Error(LABEL, "source crop allocate memory fail allocatetype: %{public}d ", source.GetAllocatorType());
+        error = IMAGE_RESULT_MALLOC_ABNORMAL;
         return false;
     }
     void* tmpDstPixels = dstPixels;
     if (!CopyPixMapToDst(source, tmpDstPixels, fd, bufferSize)) {
+        error = IMAGE_RESULT_ERR_SHAMEM_DATA_ABNORMAL;
         return false;
     }
     if (fd <= 0) {
@@ -2358,6 +2411,7 @@ bool PixelMap::DoTranslation(TransInfos &infos, const AntiAliasingOption &option
     SkTransInfo dst;
     if (!GendstTransInfo(src, dst, infos.matrix, dstMemory)) {
         HiLog::Error(LABEL, "GendstTransInfo dstMemory falied");
+        this->errorCode = IMAGE_RESULT_DECODE_FAILED;
         return false;
     }
 
diff --git a/frameworks/kits/js/common/image_pixel_map_napi_kits.cpp b/frameworks/kits/js/common/image_pixel_map_napi_kits.cpp
index 0d4403111493f229a806c6e5d829ceba0efb3117..7f4ea243f8ec294e9b01d583ab59296f90257cad 100644
--- a/frameworks/kits/js/common/image_pixel_map_napi_kits.cpp
+++ b/frameworks/kits/js/common/image_pixel_map_napi_kits.cpp
@@ -12,12 +12,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-#include "image_pixel_map_napi_kits.h"
-
 #include <map>
+#include <set>
 #include "pixel_map_napi.h"
 #include "pngpriv.h"
+#include "image_pixel_map_napi_kits.h"
 
 namespace {
     constexpr uint32_t NUM_0 = 0;
@@ -48,9 +47,13 @@ static bool isUndefine(napi_env env, napi_value value)
     return (res == napi_undefined);
 }
 
-static std::shared_ptr<PixelMap> GetPixelMap(PixelMapNapi* napi)
+static std::shared_ptr<PixelMap> GetPixelMap(PixelMapNapi* napi, PixelMapNapiArgs* args)
 {
-    if (napi == nullptr || napi->GetPixelNapiInner() == nullptr) {
+    if (napi == nullptr) {
+        args->error = IMAGE_RESULT_DATA_ABNORMAL;
+        return nullptr;
+    } else if (napi->GetPixelNapiInner() == nullptr) {
+        args->error = IMAGE_RESULT_INDEX_INVALID;
         return nullptr;
     }
     return napi->GetPixelNapiInner();
@@ -85,12 +88,12 @@ static ScaleMode ParseScaleMode(int32_t val)
 static int32_t PixelMapNapiCreate(napi_env env, PixelMapNapiArgs* args)
 {
     if (args == nullptr || args->outValue == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_INVALID_PARAMETER;
     }
     napi_value undefinedValue = nullptr;
     if ((!makeUndefined(env, &undefinedValue)) || args->inBuffer == nullptr || args->bufferLen <= NUM_0) {
         *(args->outValue) = undefinedValue;
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_GET_DATA_ABNORMAL;
     }
 
     *(args->outValue) = undefinedValue;
@@ -102,9 +105,10 @@ static int32_t PixelMapNapiCreate(napi_env env, PixelMapNapiArgs* args)
     info.size.height = args->createOptions.height;
     info.size.width = args->createOptions.width;
 
-    auto pixelmap = PixelMap::Create(static_cast<uint32_t*>(args->inBuffer), args->bufferLen, info);
+    auto pixelmap = PixelMap::Create(static_cast<uint32_t*>(args->inBuffer), args->bufferLen,
+        0, info.size.width, info, false, args->error);
     if (pixelmap == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return args->error;
     }
 
     *(args->outValue) = PixelMapNapi::CreatePixelMap(env, std::move(pixelmap));
@@ -114,12 +118,12 @@ static int32_t PixelMapNapiCreate(napi_env env, PixelMapNapiArgs* args)
 static int32_t PixelMapNapiCreateAlpha(napi_env env, PixelMapNapiArgs* args)
 {
     if (args == nullptr || args->outValue == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_INVALID_PARAMETER;
     }
     napi_value undefinedValue = nullptr;
     if ((!makeUndefined(env, &undefinedValue)) || args->inValue == nullptr) {
         *(args->outValue) = undefinedValue;
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_GET_DATA_ABNORMAL;
     }
     *(args->outValue) = undefinedValue;
 
@@ -130,28 +134,27 @@ static int32_t PixelMapNapiCreateAlpha(napi_env env, PixelMapNapiArgs* args)
 
     InitializationOptions opts;
     opts.pixelFormat = PixelFormat::ALPHA_8;
-    auto alphaPixelMap = PixelMap::Create(*pixelmap, opts);
+    Rect rect;
+    auto alphaPixelMap = PixelMap::Create(*pixelmap, rect, opts, args->error);
     if (alphaPixelMap == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return args->error;
     }
 
     *(args->outValue) = PixelMapNapi::CreatePixelMap(env, std::move(alphaPixelMap));
     return isUndefine(env, *(args->outValue))?IMAGE_RESULT_BAD_PARAMETER:IMAGE_RESULT_SUCCESS;
 }
 
-static std::shared_ptr<PixelMap> CheckAndGetPixelMap(PixelMapNapi* native, const PixelMapNapiArgs* args)
+static std::shared_ptr<PixelMap> CheckAndGetPixelMap(PixelMapNapi* native, PixelMapNapiArgs* args)
 {
-    if (args == nullptr) {
-        return nullptr;
-    }
-    return GetPixelMap(native);
+    return args == nullptr ? nullptr : GetPixelMap(native, args);
 }
 
 static int32_t PixelMapNapiGetRowBytes(PixelMapNapi* native, PixelMapNapiArgs* args)
 {
     auto pixelmap = CheckAndGetPixelMap(native, args);
     if (pixelmap == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return args != nullptr && args->error != 0 ?
+            args->error : IMAGE_RESULT_INVALID_PARAMETER;
     }
     *(args->outNum) = pixelmap->GetRowBytes();
     return IMAGE_RESULT_SUCCESS;
@@ -161,7 +164,7 @@ static int32_t PixelMapNapiIsEditable(PixelMapNapi* native, PixelMapNapiArgs* ar
 {
     auto pixelmap = CheckAndGetPixelMap(native, args);
     if (pixelmap == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_INVALID_PARAMETER;
     }
 
     *(args->outNum) = pixelmap->IsEditable();
@@ -172,7 +175,7 @@ static int32_t PixelMapNapiIsSupportAlpha(PixelMapNapi* native, PixelMapNapiArgs
 {
     auto pixelmap = CheckAndGetPixelMap(native, args);
     if (pixelmap == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_INVALID_PARAMETER;
     }
 
     *(args->outNum) = pixelmap->GetAlphaType() != AlphaType::IMAGE_ALPHA_TYPE_OPAQUE;
@@ -183,7 +186,7 @@ static int32_t PixelMapNapiSetAlphaAble(PixelMapNapi* native, PixelMapNapiArgs*
 {
     auto pixelmap = CheckAndGetPixelMap(native, args);
     if (pixelmap == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_INVALID_PARAMETER;
     }
 
     auto alphaType = pixelmap->GetAlphaType();
@@ -192,7 +195,7 @@ static int32_t PixelMapNapiSetAlphaAble(PixelMapNapi* native, PixelMapNapiArgs*
     } else if ((args->inNum0 == NUM_0) && !(alphaType == AlphaType::IMAGE_ALPHA_TYPE_OPAQUE)) {
         pixelmap->SetAlphaType(AlphaType::IMAGE_ALPHA_TYPE_OPAQUE);
     } else {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_INDEX_INVALID;
     }
 
     return IMAGE_RESULT_SUCCESS;
@@ -202,7 +205,7 @@ static int32_t PixelMapNapiGetDensity(PixelMapNapi* native, PixelMapNapiArgs* ar
 {
     auto pixelmap = CheckAndGetPixelMap(native, args);
     if (pixelmap == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_INVALID_PARAMETER;
     }
 
     *(args->outNum) = pixelmap->GetBaseDensity();
@@ -213,7 +216,7 @@ static int32_t PixelMapNapiSetDensity(PixelMapNapi* native, PixelMapNapiArgs* ar
 {
     auto pixelmap = CheckAndGetPixelMap(native, args);
     if (pixelmap == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_INVALID_PARAMETER;
     }
 
     ImageInfo imageinfo;
@@ -221,7 +224,7 @@ static int32_t PixelMapNapiSetDensity(PixelMapNapi* native, PixelMapNapiArgs* ar
     if (imageinfo.baseDensity != args->inNum0) {
         imageinfo.baseDensity = args->inNum0;
         if (pixelmap->SetImageInfo(imageinfo, true) != IMAGE_RESULT_SUCCESS) {
-            return IMAGE_RESULT_BAD_PARAMETER;
+            return IMAGE_RESULT_INDEX_INVALID;
         }
     }
     return IMAGE_RESULT_SUCCESS;
@@ -231,11 +234,11 @@ static int32_t PixelMapNapiSetOpacity(PixelMapNapi* native, PixelMapNapiArgs* ar
 {
     auto pixelmap = CheckAndGetPixelMap(native, args);
     if (pixelmap == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_INVALID_PARAMETER;
     }
 
     if (pixelmap->SetAlpha(args->inFloat0) != IMAGE_RESULT_SUCCESS) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_INDEX_INVALID;
     }
     return IMAGE_RESULT_SUCCESS;
 }
@@ -244,50 +247,50 @@ static int32_t PixelMapNapiScale(PixelMapNapi* native, PixelMapNapiArgs* args)
 {
     auto pixelmap = CheckAndGetPixelMap(native, args);
     if (pixelmap == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_INVALID_PARAMETER;
     }
     pixelmap->scale(args->inFloat0, args->inFloat1);
-    return IMAGE_RESULT_SUCCESS;
+    return pixelmap->errorCode == 0 ? IMAGE_RESULT_SUCCESS : pixelmap->errorCode;
 }
 
 static int32_t PixelMapNapiTranslate(PixelMapNapi* native, PixelMapNapiArgs* args)
 {
     auto pixelmap = CheckAndGetPixelMap(native, args);
     if (pixelmap == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_INVALID_PARAMETER;
     }
 
     pixelmap->translate(args->inFloat0, args->inFloat1);
-    return IMAGE_RESULT_SUCCESS;
+    return pixelmap->errorCode == 0 ? IMAGE_RESULT_SUCCESS : pixelmap->errorCode;
 }
 
 static int32_t PixelMapNapiRotate(PixelMapNapi* native, PixelMapNapiArgs* args)
 {
     auto pixelmap = CheckAndGetPixelMap(native, args);
     if (pixelmap == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_INVALID_PARAMETER;
     }
 
     pixelmap->rotate(args->inFloat0);
-    return IMAGE_RESULT_SUCCESS;
+    return pixelmap->errorCode == 0 ? IMAGE_RESULT_SUCCESS : pixelmap->errorCode;
 }
 
 static int32_t PixelMapNapiFlip(PixelMapNapi* native, PixelMapNapiArgs* args)
 {
     auto pixelmap = CheckAndGetPixelMap(native, args);
     if (pixelmap == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_INVALID_PARAMETER;
     }
 
     pixelmap->flip((args->inNum0 == NUM_1), (args->inNum1 == NUM_1));
-    return IMAGE_RESULT_SUCCESS;
+    return pixelmap->errorCode == 0 ? IMAGE_RESULT_SUCCESS : pixelmap->errorCode;
 }
 
 static int32_t PixelMapNapiCrop(PixelMapNapi* native, PixelMapNapiArgs* args)
 {
     auto pixelmap = CheckAndGetPixelMap(native, args);
     if (pixelmap == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_INVALID_PARAMETER;
     }
     Rect region;
     region.left = args->inNum0;
@@ -295,14 +298,14 @@ static int32_t PixelMapNapiCrop(PixelMapNapi* native, PixelMapNapiArgs* args)
     region.width = args->inNum2;
     region.height = args->inNum3;
     pixelmap->crop(region);
-    return IMAGE_RESULT_SUCCESS;
+    return pixelmap->errorCode == 0 ? IMAGE_RESULT_SUCCESS : pixelmap->errorCode;
 }
 
 static int32_t PixelMapNapiGetImageInfo(PixelMapNapi* native, PixelMapNapiArgs* args)
 {
     auto pixelmap = CheckAndGetPixelMap(native, args);
     if (pixelmap == nullptr || args->outInfo == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_INVALID_PARAMETER;
     }
 
     ImageInfo srcInfo;
@@ -311,26 +314,28 @@ static int32_t PixelMapNapiGetImageInfo(PixelMapNapi* native, PixelMapNapiArgs*
     args->outInfo->height = srcInfo.size.height;
     args->outInfo->rowSize = pixelmap->GetRowBytes();
     args->outInfo->pixelFormat = static_cast<int32_t>(srcInfo.pixelFormat);
-    return IMAGE_RESULT_SUCCESS;
+    return pixelmap->errorCode == 0 ? IMAGE_RESULT_SUCCESS : pixelmap->errorCode;
 }
 
 static int32_t PixelMapNapiAccessPixels(PixelMapNapi* native, PixelMapNapiArgs* args)
 {
     auto pixelmap = CheckAndGetPixelMap(native, args);
     if (pixelmap == nullptr) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_INVALID_PARAMETER;
     }
     native->LockPixelMap();
     *(args->outAddr) = static_cast<uint8_t*>(pixelmap->GetWritablePixels());
-    return IMAGE_RESULT_SUCCESS;
+    return pixelmap->errorCode == 0 ? IMAGE_RESULT_SUCCESS : pixelmap->errorCode;
 }
 
 static int32_t PixelMapNapiUnAccessPixels(PixelMapNapi* native, PixelMapNapiArgs* args)
 {
     if (native != nullptr) {
         native->UnlockPixelMap();
+        return IMAGE_RESULT_SUCCESS;
+    } else {
+        return IMAGE_RESULT_INVALID_PARAMETER;
     }
-    return IMAGE_RESULT_SUCCESS;
 }
 
 static const std::map<int32_t, PixelMapNapiEnvFunc> g_EnvFunctions = {
@@ -360,7 +365,7 @@ int32_t PixelMapNapiNativeEnvCall(int32_t mode, napi_env env, PixelMapNapiArgs*
 {
     auto funcSearch = g_EnvFunctions.find(mode);
     if (funcSearch == g_EnvFunctions.end()) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_JNI_ENV_ABNORMAL;
     }
     return funcSearch->second(env, args);
 }
@@ -370,7 +375,7 @@ int32_t PixelMapNapiNativeCtxCall(int32_t mode, PixelMapNapi* native, PixelMapNa
 {
     auto funcSearch = g_CtxFunctions.find(mode);
     if (funcSearch == g_CtxFunctions.end()) {
-        return IMAGE_RESULT_BAD_PARAMETER;
+        return IMAGE_RESULT_JNI_ENV_ABNORMAL;
     }
     return funcSearch->second(native, args);
 }
diff --git a/frameworks/kits/js/common/include/image_pixel_map_napi_kits.h b/frameworks/kits/js/common/include/image_pixel_map_napi_kits.h
index f4fd0f0db379bff350f3a9d6a1937fd6cec2dbcd..96d1904aea6e390ac89a09b4a36e067d206cbd41 100644
--- a/frameworks/kits/js/common/include/image_pixel_map_napi_kits.h
+++ b/frameworks/kits/js/common/include/image_pixel_map_napi_kits.h
@@ -41,6 +41,7 @@ struct PixelMapNapiArgs {
     int32_t* outNum;
     OhosPixelMapInfos *outInfo;
     void** outAddr;
+    int32_t error;
 };
 
 using PixelMapNapiArgs = struct PixelMapNapiArgs;
@@ -67,6 +68,7 @@ enum {
 PixelMapNapi* PixelMapNapi_Unwrap(napi_env env, napi_value value);
 int32_t PixelMapNapiNativeEnvCall(int32_t mode, napi_env env, PixelMapNapiArgs* args);
 int32_t PixelMapNapiNativeCtxCall(int32_t mode, PixelMapNapi* native, PixelMapNapiArgs* args);
+
 #ifdef __cplusplus
 };
 #endif
diff --git a/frameworks/kits/js/common/pixelmap_ndk/BUILD.gn b/frameworks/kits/js/common/pixelmap_ndk/BUILD.gn
index bfb31bb360146ffaa6a23a184a570ba48a187638..51065b96161effcdf8ee2fce30c8d7b559d5497c 100644
--- a/frameworks/kits/js/common/pixelmap_ndk/BUILD.gn
+++ b/frameworks/kits/js/common/pixelmap_ndk/BUILD.gn
@@ -12,6 +12,7 @@
 # limitations under the License.
 
 import("//build/ohos.gni")
+import("//foundation/multimedia/image_framework/ide/image_decode_config.gni")
 
 SUBSYSTEM_DIR = "//foundation/multimedia/image_framework"
 
@@ -22,6 +23,7 @@ ohos_shared_library("pixelmap_ndk") {
     debug = false
   }
   include_dirs = [
+    "${image_subsystem}/interfaces/innerkits/include/mdkKits",
     "include",
     "//foundation/arkui/napi/interfaces/inner_api",
     "//foundation/arkui/napi/interfaces/kits",
diff --git a/frameworks/kits/js/common/pixelmap_ndk/image_pixel_map_ndk.cpp b/frameworks/kits/js/common/pixelmap_ndk/image_pixel_map_ndk.cpp
index 0ff6d1bc0efd60b942b1efafc4456626569558de..722352ad7838cb48347685fc17c14db4a50d15d1 100644
--- a/frameworks/kits/js/common/pixelmap_ndk/image_pixel_map_ndk.cpp
+++ b/frameworks/kits/js/common/pixelmap_ndk/image_pixel_map_ndk.cpp
@@ -14,19 +14,15 @@
  */
 
 #include "image_pixel_map_mdk.h"
-
-#include "common_utils.h"
 #include "image_pixel_map_napi_kits.h"
+#include "native_pixel_map.h"
+#include "common_utils.h"
 
 using namespace OHOS::Media;
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-struct NativePixelMap_ {
-    PixelMapNapi* napi = nullptr;
-};
-
 MIDK_EXPORT
 NativePixelMap* OH_PixelMap_InitNativePixelMap(napi_env env, napi_value source)
 {
@@ -53,6 +49,7 @@ int32_t OH_PixelMap_CreatePixelMap(napi_env env, OhosPixelMapCreateOps info,
     args.inBuffer = buf;
     args.bufferLen = len;
     args.outValue = res;
+    args.error = 0;
     return PixelMapNapiNativeEnvCall(ENV_FUNC_CREATE, env, &args);
 }
 
@@ -62,6 +59,7 @@ int32_t OH_PixelMap_CreateAlphaPixelMap(napi_env env, napi_value source, napi_va
     PixelMapNapiArgs args;
     args.inValue = source;
     args.outValue = alpha;
+    args.error = 0;
     return PixelMapNapiNativeEnvCall(ENV_FUNC_CREATE_ALPHA, env, &args);
 }
 
@@ -74,6 +72,7 @@ int32_t OH_PixelMap_GetBytesNumberPerRow(const NativePixelMap* native, int32_t*
     }
     PixelMapNapiArgs args;
     args.outNum = num;
+    args.error = 0;
     return PixelMapNapiNativeCtxCall(CTX_FUNC_GET_ROW_BYTES, native->napi, &args);
 }
 
@@ -96,6 +95,7 @@ int32_t OH_PixelMap_IsSupportAlpha(const NativePixelMap* native, int32_t* alpha)
     }
     PixelMapNapiArgs args;
     args.outNum = alpha;
+    args.error = 0;
     return PixelMapNapiNativeCtxCall(CTX_FUNC_IS_SUPPORT_ALPHA, native->napi, &args);
 }
 
@@ -107,6 +107,7 @@ int32_t OH_PixelMap_SetAlphaAble(const NativePixelMap* native, int32_t alpha)
     }
     PixelMapNapiArgs args;
     args.inNum0 = alpha;
+    args.error = 0;
     return PixelMapNapiNativeCtxCall(CTX_FUNC_SET_ALPHAABLE, native->napi, &args);
 }
 
@@ -118,6 +119,7 @@ int32_t OH_PixelMap_GetDensity(const NativePixelMap* native, int32_t* density)
     }
     PixelMapNapiArgs args;
     args.outNum = density;
+    args.error = 0;
     return PixelMapNapiNativeCtxCall(CTX_FUNC_GET_DENSITY, native->napi, &args);
 }
 
@@ -129,6 +131,7 @@ int32_t OH_PixelMap_SetDensity(const NativePixelMap* native, int32_t density)
     }
     PixelMapNapiArgs args;
     args.inNum0 = density;
+    args.error = 0;
     return PixelMapNapiNativeCtxCall(CTX_FUNC_SET_DENSITY, native->napi, &args);
 }
 
@@ -140,6 +143,7 @@ int32_t OH_PixelMap_SetOpacity(const NativePixelMap* native, float opacity)
     }
     PixelMapNapiArgs args;
     args.inFloat0 = opacity;
+    args.error = 0;
     return PixelMapNapiNativeCtxCall(CTX_FUNC_SET_OPACITY, native->napi, &args);
 }
 
@@ -152,6 +156,7 @@ int32_t OH_PixelMap_Scale(const NativePixelMap* native, float x, float y)
     PixelMapNapiArgs args;
     args.inFloat0 = x;
     args.inFloat1 = y;
+    args.error = 0;
     return PixelMapNapiNativeCtxCall(CTX_FUNC_SCALE, native->napi, &args);
 }
 
@@ -164,6 +169,7 @@ int32_t OH_PixelMap_Translate(const NativePixelMap* native, float x, float y)
     PixelMapNapiArgs args;
     args.inFloat0 = x;
     args.inFloat1 = y;
+    args.error = 0;
     return PixelMapNapiNativeCtxCall(CTX_FUNC_TRANSLATE, native->napi, &args);
 }
 
@@ -175,6 +181,7 @@ int32_t OH_PixelMap_Rotate(const NativePixelMap* native, float angle)
     }
     PixelMapNapiArgs args;
     args.inFloat0 = angle;
+    args.error = 0;
     return PixelMapNapiNativeCtxCall(CTX_FUNC_ROTATE, native->napi, &args);
 }
 
@@ -187,6 +194,7 @@ int32_t OH_PixelMap_Flip(const NativePixelMap* native, int32_t x, int32_t y)
     PixelMapNapiArgs args;
     args.inNum0 = x;
     args.inNum1 = y;
+    args.error = 0;
     return PixelMapNapiNativeCtxCall(CTX_FUNC_FLIP, native->napi, &args);
 }
 
@@ -201,6 +209,7 @@ int32_t OH_PixelMap_Crop(const NativePixelMap* native, int32_t x, int32_t y, int
     args.inNum1 = y;
     args.inNum2 = width;
     args.inNum3 = height;
+    args.error = 0;
     return PixelMapNapiNativeCtxCall(CTX_FUNC_CROP, native->napi, &args);
 }
 
@@ -212,6 +221,7 @@ int32_t OH_PixelMap_GetImageInfo(const NativePixelMap* native, OhosPixelMapInfos
     }
     PixelMapNapiArgs args;
     args.outInfo = info;
+    args.error = 0;
     return PixelMapNapiNativeCtxCall(CTX_FUNC_GET_IMAGE_INFO, native->napi, &args);
 }
 
@@ -223,6 +233,7 @@ int32_t OH_PixelMap_AccessPixels(const NativePixelMap* native, void** addr)
     }
     PixelMapNapiArgs args;
     args.outAddr = addr;
+    args.error = 0;
     return PixelMapNapiNativeCtxCall(CTX_FUNC_ACCESS_PIXELS, native->napi, &args);
 }
 
@@ -233,6 +244,7 @@ int32_t OH_PixelMap_UnAccessPixels(const NativePixelMap* native)
         return IMAGE_RESULT_BAD_PARAMETER;
     }
     PixelMapNapiArgs args;
+    args.error = 0;
     return PixelMapNapiNativeCtxCall(CTX_FUNC_UNACCESS_PIXELS, native->napi, &args);
 }
 
diff --git a/interfaces/innerkits/include/mdkKits/native_pixel_map.h b/interfaces/innerkits/include/mdkKits/native_pixel_map.h
new file mode 100644
index 0000000000000000000000000000000000000000..436c0118bd3e4819f28800317a6ee398b4dac857
--- /dev/null
+++ b/interfaces/innerkits/include/mdkKits/native_pixel_map.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NATIVE_PIXEL_MAP_H_
+#define NATIVE_PIXEL_MAP_H_
+
+#include "pixel_map_napi.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct NativePixelMap_ {
+    OHOS::Media::PixelMapNapi* napi = nullptr;
+};
+
+#ifdef __cplusplus
+};
+#endif
+
+shared_ptr<OHOS::Media::PixelMap> OH_PixelMapNative_GetPixelMap(struct NativePixelMap_ *nativePixelMap)
+{
+    return nativePixelMap == nullptr ? nullptr :
+	nativePixelMap->napi == nullptr ? nullptr :
+	    nativePixelMap->napi->GetPixelNapiInner();
+}
+#endif // NATIVE_PIXEL_MAP_H_
diff --git a/interfaces/innerkits/include/pixel_map.h b/interfaces/innerkits/include/pixel_map.h
index 7e2a32ee60e5b3c9023cdf5998e26ec17c1e836e..4a1b046b331f2d4c07498736088638bf02411f0b 100644
--- a/interfaces/innerkits/include/pixel_map.h
+++ b/interfaces/innerkits/include/pixel_map.h
@@ -74,10 +74,15 @@ public:
                                                          int32_t stride, const InitializationOptions &opts);
     NATIVEEXPORT static std::unique_ptr<PixelMap> Create(const uint32_t *colors, uint32_t colorLength, int32_t offset,
         int32_t stride, const InitializationOptions &opts, bool useCustomFormat);
+    NATIVEEXPORT static std::unique_ptr<PixelMap> Create(const uint32_t *colors, uint32_t colorLength, int32_t offset,
+        int32_t stride, const InitializationOptions &opts, bool useCustomFormat, int32_t &errorCode);
     NATIVEEXPORT static std::unique_ptr<PixelMap> Create(const InitializationOptions &opts);
     NATIVEEXPORT static std::unique_ptr<PixelMap> Create(PixelMap &source, const InitializationOptions &opts);
     NATIVEEXPORT static std::unique_ptr<PixelMap> Create(PixelMap &source, const Rect &srcRect,
                                                          const InitializationOptions &opts);
+    NATIVEEXPORT static std::unique_ptr<PixelMap> Create(PixelMap &source, const Rect &srcRect,
+        const InitializationOptions &opts, int32_t &errorCode);
+
     NATIVEEXPORT virtual uint32_t SetImageInfo(ImageInfo &info);
     NATIVEEXPORT virtual uint32_t SetImageInfo(ImageInfo &info, bool isReused);
     NATIVEEXPORT virtual const uint8_t *GetPixel(int32_t x, int32_t y);
@@ -243,15 +248,20 @@ private:
     static bool BGRA8888ToARGB(const uint8_t *in, uint32_t inCount, uint32_t *out, uint32_t outCount);
     static bool RGB888ToARGB(const uint8_t *in, uint32_t inCount, uint32_t *out, uint32_t outCount);
     static bool CheckParams(const uint32_t *colors, uint32_t colorLength, int32_t offset, int32_t stride,
-                            const InitializationOptions &opts);
+        const InitializationOptions &opts);
+    static bool CheckParams(const uint32_t *colors, uint32_t colorLength, int32_t offset, int32_t stride,
+        const InitializationOptions &opts, int &error);
     static void UpdatePixelsAlpha(const AlphaType &alphaType, const PixelFormat &pixelFormat, uint8_t *dstPixels,
                                   PixelMap dstPixelMap);
     static void InitDstImageInfo(const InitializationOptions &opts, const ImageInfo &srcImageInfo,
                                  ImageInfo &dstImageInfo);
     static bool CopyPixMapToDst(PixelMap &source, void* &dstPixels, int &fd, uint32_t bufferSize);
+    static bool CopyPixelMap(PixelMap &source, PixelMap &dstPixelMap, int32_t &error);
     static bool CopyPixelMap(PixelMap &source, PixelMap &dstPixelMap);
     static bool SourceCropAndConvert(PixelMap &source, const ImageInfo &srcImageInfo, const ImageInfo &dstImageInfo,
-                                     const Rect &srcRect, PixelMap &dstPixelMap);
+        const Rect &srcRect, PixelMap &dstPixelMap, int &error);
+    static bool SourceCropAndConvert(PixelMap &source, const ImageInfo &srcImageInfo, const ImageInfo &dstImageInfo,
+        const Rect &srcRect, PixelMap &dstPixelMap);
     static bool IsSameSize(const Size &src, const Size &dst);
     static bool ScalePixelMap(const Size &targetSize, const Size &dstSize, const ScaleMode &scaleMode,
                               PixelMap &dstPixelMap);
