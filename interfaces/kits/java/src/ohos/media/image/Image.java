/*
 * Copyright (C) 2021 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ohos.media.image;

import ohos.media.image.common.ImageFormat;
import ohos.media.image.common.Rect;
import ohos.media.image.common.Size;
import ohos.media.utils.log.Logger;
import ohos.media.utils.log.LoggerFactory;
import ohos.utils.system.SystemCap;
import ohos.utils.system.SystemCapability;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;


/**
 * Provides basic image operations, including obtaining image information, and reading and writing image data.
 *
 * <p>An {@code Image} object can be generated by an {@link ImageReceiver} object.
 *
 * @Syscap {@link SystemCapability.Multimedia#IMAGE}
 * @since 1
 */
@SystemCap("SystemCapability.Multimedia.Image")
public class Image {
    private static final Logger LOGGER = LoggerFactory.getImageLogger(Image.class);

    /**
     * Image availability status
     */
    private volatile boolean isImageValid = false;

    /**
     * Timestamp in nanosecond
     */
    private long timestamp = 0L;

    /**
     * Clip rectangle
     */
    private Rect clipRect;

    /**
     * Color components
     */
    private Component[] components;

    /**
     * Image Receiver
     */
    private ImageReceiver imageReceiver;

    /**
     * Native used,tracing native object
     */
    private long nativeBuffer;

    /**
     * Constructor
     *
     * @param imageReceiver The image receiver.
     */
    Image(ImageReceiver imageReceiver) {
        if (imageReceiver == null) {
            LOGGER.error("imageReceiver is null.");
            throw new IllegalArgumentException("imageReceiver is null.");
        }
        this.imageReceiver = imageReceiver;
    }

    /**
     * Set the image status.
     *
     * @param isImageValid The image status.
     */
    void setImageStatus(boolean isImageValid) {
        this.isImageValid = isImageValid;
    }

    /**
     * Get the image status.
     *
     * @return The image status.
     */
    boolean getImageStatus() {
        return isImageValid;
    }

    /**
     * Obtains the image format.
     *
     * @return Returns the image format, which is defined by {@link ImageFormat}.
     * @throws IllegalStateException Throws this exception if the operation is not supported,
     * for example, if native resources associated with the receiver or image are released.
     * @since 1
     */
    public int getFormat() {
        checkImageIsValid();
        return nativeGetFormat(imageReceiver.getImageFormat());
    }

    /**
     * Obtains the image size.
     *
     * @return Returns the image size, which is specified by a {@link Size} object.
     * @throws IllegalStateException Throws this exception if the operation is not supported,
     * for example, if native resources associated with the receiver or image are released.
     * @since 1
     */
    public Size getImageSize() {
        checkImageIsValid();
        // JPEG/H264/H265 size is come from ImageReceiver
        int format = getFormat();
        if (format == ImageFormat.JPEG || format == ImageFormat.H264 || format == ImageFormat.H265) {
            return imageReceiver.getImageSize();
        }
        return nativeGetSize();
    }

    /**
     * Obtains the image timestamp, in nanoseconds.
     *
     * @return Returns the timestamp.
     * @throws IllegalStateException Throws this exception if the operation is not supported,
     * for example, if native resources associated with the receiver or image are released.
     * @since 1
     */
    public long getTimestamp() {
        checkImageIsValid();
        return timestamp;
    }

    /**
     * Obtains the cropped area of an image.
     *
     * @return Returns the cropped area, which is specified by a {@link Rect} object.
     * @throws IllegalStateException Throws this exception if the operation is not supported,
     * for example, if native resources associated with the receiver or image are released.
     * @since 1
     */
    public Rect getClipRect() {
        checkImageIsValid();
        if (clipRect == null) {
            Size imageSize = getImageSize();
            return new Rect(0, 0, imageSize.width, imageSize.height);
        } else {
            return new Rect(clipRect);
        }
    }

    /**
     * Sets the image area to crop.
     *
     * <p>If the area exceeds the image size or is outside of the image, the cropping will not be operated.
     *
     * @param clipRect Indicates the image area to crop, which is specified by a {@link Rect} object.
     * @throws IllegalStateException Throws this exception if the operation is not supported,
     * for example, if native resources associated with the receiver or image are released.
     * @since 1
     */
    public void setClipRect(Rect clipRect) {
        checkImageIsValid();
        if (clipRect != null) {
            Rect clipRectCopy = new Rect(clipRect);
            Size imageSize = getImageSize();
            if (!clipRectCopy.cropRect(0, 0, imageSize.width, imageSize.height)) {
                clipRectCopy.setEmpty();
            }
            this.clipRect = clipRectCopy;
        } else {
            this.clipRect = clipRect;
        }
    }

    /**
     * Releases native resources associated with the image.
     *
     * <p>After the image data is released, any image operation will not be supported.
     *
     * @since 1
     */
    public void release() {
        if (!isImageValid) {
            return;
        }
        // image need to know who produce it
        nativeReleaseImage(imageReceiver);
        isImageValid = false;
        if (components != null) {
            for (Component component : components) {
                component.release();
            }
        }
        components = null;
    }

    @Override
    protected void finalize() throws Throwable {
        try {
            release();
        } finally {
            super.finalize();
        }
    }

    /**
     * Obtains the color component based on a specified component type.
     *
     * @param componentType Indicates a color component type, which is specified by {@link ImageFormat.ComponentType}.
     * @return Returns the image color component if obtained; returns {@code null} if the image does not
     * have the type of color component.
     * @throws IllegalStateException Throws this exception if the operation is not supported,
     * for example, if native resources associated with the receiver or image are released.
     * @since 1
     */
    public Component getComponent(ImageFormat.ComponentType componentType) {
        checkImageIsValid();
        if (componentType == null) {
            LOGGER.error("component type is null.");
            return null;
        }
        if (components == null) {
            initComponents();
        }
        if (components != null) {
            for (Component component : components) {
                if (componentType == component.componentType) {
                    return component;
                }
            }
        }
        LOGGER.error("component type %{public}s mismatch native acquire.", componentType);
        return null;
    }

    /**
     * Get all component data from native.
     *
     * @throws IllegalStateException Error when image is invalid.
     */
    private void initComponents() {
        checkImageIsValid();
        int format = imageReceiver.getImageFormat();
        components = nativeGetComponents(ImageFormat.getComponentNumber(format), format);
    }

    /**
     * Check image is valid.
     *
     * @throws IllegalStateException Error when image is invalid.
     */
    private void checkImageIsValid() {
        if (!isImageValid) {
            throw new IllegalStateException("image state is invalid");
        }
    }

    /**
     * Describes image color components.
     *
     * <p>This class provides methods for obtaining image color component attributes,
     * and reading and writing color component data.
     *
     * @since 1
     */
    public static class Component {
        /**
         * Describes results of color component–related operations.
         *
         * @since 1
         */
        public static final class OperationResult {
            /**
             * Indicates that the color component–related operation is successful.
             *
             * @since 1
             */
            public static final int SUCCESS = 0;

            /**
             * Indicates that the color component–related operation fails.
             *
             * @since 1
             */
            public static final int FAILURE = -1;

            /**
             * Indicates that the operation is not supported because the specified color component has been released.
             *
             * @since 1
             */
            public static final int RELEASED = -2;

            private OperationResult() {}
        }

        /**
         * Byte unsigned mask.
         */
        private static final int UNSIGNED_BYTE_MASK = 0xFF;

        /**
         * Indicates the color component type defined in {@link ImageFormat.ComponentType}.
         *
         * @since 1
         */
        public final ImageFormat.ComponentType componentType;

        /**
         * Indicates the distance in bytes between adjacent pixel rows.
         *
         * @since 1
         */
        public final int rowStride;

        /**
         * Indicates the distance in bytes between adjacent pixels in a row.
         *
         * @since 1
         */
        public final int pixelStride;

        /**
         * Buffer of image data.
         */
        private ByteBuffer byteBuffer;

        /**
         * Default constructor, be created by native.
         *
         * @param componentType ComponentType value {@link ImageFormat.ComponentType}.
         * @param rowStride Distance of adjacent row pixels.
         * @param pixelStride Distance of adjacent pixels.
         * @param byteBuffer Buffer of image data.
         */
        private Component(int componentType, int rowStride, int pixelStride, ByteBuffer byteBuffer) {
            this.componentType = ImageFormat.ComponentType.valueOf(componentType);
            this.rowStride = rowStride;
            this.pixelStride = pixelStride;
            this.byteBuffer = byteBuffer;
            // Set the byteBuffer order in native order, otherwise the default order is BIG_ENDIAN
            this.byteBuffer.order(ByteOrder.nativeOrder());
        }

        /**
         * Reads color component data of one byte.
         *
         * @return Returns the data if the reading is successful; returns {@link OperationResult#FAILURE}
         * constant if the reading fails; returns the {@link OperationResult#RELEASED} constant if the
         * image or component data is released.
         * @since 1
         */
        public int read() {
            try {
                checkParameterIsValid();
                return (byteBuffer.get() & UNSIGNED_BYTE_MASK);
            } catch (IllegalStateException e) {
                LOGGER.error("component has been released.");
                return OperationResult.RELEASED;
            } catch (BufferUnderflowException e) {
                LOGGER.error("read byte occurs exception.");
                return OperationResult.FAILURE;
            }
        }

        /**
         * Reads color component data of multiple consecutive bytes.
         *
         * @param dstArray Indicates an array to store the data.
         * @return Returns the {@link OperationResult#SUCCESS} constant if the reading is successful;
         * returns the {@link OperationResult#FAILURE} constant if the reading fails; returns the
         * {@link OperationResult#RELEASED} constant if the image or component data is released.
         * @since 1
         */
        public int read(byte[] dstArray) {
            try {
                checkParameterIsValid();
                byteBuffer.get(dstArray);
                return OperationResult.SUCCESS;
            } catch (IllegalStateException e) {
                LOGGER.error("component has been released.");
                return OperationResult.RELEASED;
            } catch (BufferUnderflowException e) {
                LOGGER.error("read bulk byte occurs exception.");
                return OperationResult.FAILURE;
            }
        }

        /**
         * Reads color component data of multiple consecutive bytes and write the data in an
         * array with specified offsets and length.
         *
         * @param dstArray Indicates an array to store the data.
         * @param offset Indicates where to write the data in the target array.
         * @param length Indicates the maximum length allowed to write data into the target array.
         * @return Returns the {@link OperationResult#SUCCESS} constant if the reading is successful;
         * returns the {@link OperationResult#FAILURE} constant if the reading fails; returns the
         * {@link OperationResult#RELEASED} constant if the image or component data is released.
         * @since 1
         */
        public int read(byte[] dstArray, int offset, int length) {
            try {
                checkParameterIsValid();
                byteBuffer.get(dstArray, offset, length);
                return OperationResult.SUCCESS;
            } catch (IllegalStateException e) {
                LOGGER.error("component has been released.");
                return OperationResult.RELEASED;
            } catch (BufferUnderflowException | IndexOutOfBoundsException e) {
                LOGGER.error("read bulk byte occurs exception.");
                return OperationResult.FAILURE;
            }
        }

        /**
         * Obtains the position of the current color component data to read.
         *
         * @return Returns the position of the current color component data if obtained; returns the
         * {@link OperationResult#RELEASED} if the image or component data is released.
         * @since 1
         */
        public int tell() {
            try {
                checkParameterIsValid();
                return byteBuffer.position();
            } catch (IllegalStateException e) {
                LOGGER.error("tell position occurs exception.");
                return OperationResult.RELEASED;
            }
        }

        /**
         * Sets a position of the current color component data to read.
         *
         * @param newPosition Indicates a new position of the current color component data to read.
         * @return Returns the {@link OperationResult#SUCCESS} constant if the reading position is set;
         * returns the {@link OperationResult#FAILURE} constant if the setting fails; returns the
         * {@link OperationResult#RELEASED} constant if the image or component data is released.
         * @since 1
         */
        public int seek(int newPosition) {
            try {
                checkParameterIsValid();
                byteBuffer.position(newPosition);
                return OperationResult.SUCCESS;
            } catch (IllegalStateException e) {
                LOGGER.error("component has been released.");
                return OperationResult.RELEASED;
            } catch (IllegalArgumentException e) {
                LOGGER.error("seek position occurs exception.");
                return OperationResult.FAILURE;
            }
        }

        /**
         * Obtains the remaining data size (in bytes) of the color component.
         *
         * @return Returns the bytes of the remaining data if obtained; returns the {@link OperationResult#RELEASED}
         * if the image or component data is released.
         * @since 1
         */
        public int remaining() {
            try {
                checkParameterIsValid();
                return byteBuffer.remaining();
            } catch (IllegalStateException e) {
                LOGGER.error("component has been released.");
                return OperationResult.RELEASED;
            }
        }

        /**
         * Obtains the {@link java.nio.ByteBuffer} object of the current color component. Note that the object directly
         * maps to the native resource buffer. After the receiver or image resource is released, the object should
         * not be used to read or write data.
         *
         * @return Returns the {@link java.nio.ByteBuffer} object of the current color component.
         * @throws IllegalStateException Throws this exception if the operation is not supported,
         * for example, if native resources associated with the receiver or image are released.
         * @since 1
         */
        public ByteBuffer getBuffer() {
            checkParameterIsValid();
            return byteBuffer;
        }

        /**
         * Releases native resources associated with the color component.
         *
         * <p>After this method is called, color component-related operations will no longer be supported.
         *
         * @since 1
         */
        public void release() {
            if (byteBuffer == null) {
                return;
            }
            if (byteBuffer.isDirect()) {
                reflectFreeDirectBuffer(byteBuffer);
            }
            byteBuffer = null;
        }

        private void checkParameterIsValid() {
            if (byteBuffer == null) {
                throw new IllegalStateException("image or buffer is invalid");
            }
        }

        /**
         * Reflect invoke NioUtils freeDirectBuffer method.
         *
         * @param byteBuffer DirectByteBuffer object.
         */
        private void reflectFreeDirectBuffer(ByteBuffer byteBuffer) {
            try {
                Class<?> nioUtilsClz = Class.forName("java.nio.NioUtils");
                Method freeBufferMethod = nioUtilsClz.getMethod("freeDirectBuffer", java.nio.ByteBuffer.class);
                freeBufferMethod.invoke(null, byteBuffer);
            } catch (IllegalAccessException | ClassNotFoundException | InvocationTargetException
                    | NoSuchMethodException e) {
                LOGGER.error("reflect free direct buffer error %{public}s", e.getMessage());
            }
        }
    }

    private synchronized native int nativeGetFormat(int receiverFormat);

    private synchronized native Size nativeGetSize();

    private synchronized native Component[] nativeGetComponents(int componentNumber, int receiverFormat);

    private synchronized native void nativeReleaseImage(ImageReceiver imageReceiver);
}
