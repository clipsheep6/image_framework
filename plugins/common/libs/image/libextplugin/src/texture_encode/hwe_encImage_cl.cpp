/*
 * Copyright (C) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <cmath>
#include <fstream>
#include <securec.h>

#include "hwe_encImage_cl.h"

#include "abs_image_encoder.h"
#include "hilog/log.h"
#include "log_tags.h"

#define BIT_SHIFT_8BITS (8)
#define BIT_SHIFT_16BITS (16)
#define BIT_SHIFT_24BITS (24)
#define BYTES_MASK (0xFF)

#define HALF_BYTES_MASK (0xF)

#define MAGIC_LENTH (4)
#define XYZ_BYTES (3)

#define GLOBAL_WH_NUM_CL (2)

#define HASH_MAGIC_SEED_BIT (15)
#define HASH_MAGIC_SEED (0xEEDE0891)
#define HASH_SEED_1 (5)
#define HASH_SEED_2 (16)
#define HASH_SEED_3 (7)
#define HASH_SEED_4 (3)
#define HASH_SEED_5 (6)
#define HASH_SEED_6 (17)
#define STRIDE_RGBA_LOG2 (2)

namespace OHOS {
namespace Media {
using namespace OHOS::HiviewDFX;
namespace {
constexpr OHOS::HiviewDFX::HiLogLabel LABEL = { LOG_CORE,LOG_TAG_DOMAIN_ID_PLUGIN,"ExtEncoder"};
}

const char *g_programSource = R"(
#define DIM 4
#define BLOCK_SIZE 16 // DIM * DIM 
#define X_GRIDS 4
#define Y_GRIDS 4
#define SMALL_VALUE 0.00001f
#define BLOCK_MAX_WEIGHTS 64
#define BLOCK_MAX_WEIGHTS_2PLANE 32
#define WEIGHTS_PLANE2_OFFSET BLOCK_MAX_WEIGHTS_2PLANE
#define CEM_LDR_RGB_DIRECT 8u
#define CEM_LDR_RGB_BASE_OFFSET 9u
#define CEM_LDR_RGBA_DIRECT 12u
#define CEM_LDR_RGBA_BASE_OFFSET 13u

#define    QUANT_2 0
#define    QUANT_3 1
#define    QUANT_4 2
#define    QUANT_5 3
#define    QUANT_6 4
#define    QUANT_8 5
#define    QUANT_10 6
#define    QUANT_12 7
#define    QUANT_16 8
#define    QUANT_20 9
#define    QUANT_24 10
#define    QUANT_32 11
#define    QUANT_40 12
#define    QUANT_48 13
#define    QUANT_64 14
#define    QUANT_80 15
#define    QUANT_96 16
#define    QUANT_128 17
#define    QUANT_160 18
#define    QUANT_192 19
#define    QUANT_256 20
#define    QUANT_MAX 21

#define WEIGHT_QUANTIZE_NUM 32
#define COLOR_NUM 256

#define MAX_PARTITION_COUNT 4
#define PARTITION_COUNT 2


typedef struct{
    int partid;
    uint bitmaps[2];
} PartInfo;

int get_part(PartInfo* part_info, int i)
{
    if(i >= 32){
        return 0;    
    }
    return (int)(((*part_info).bitmaps[1]>>i)&0x1u);
}

#define PARTITION_ORDER_MAX 5
#define WEIGHT_QUANTIZE_NUM 32
__constant short scramble_table[12 * WEIGHT_QUANTIZE_NUM] = {
    0, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
    0, 1, 2,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 2, 3,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 2, 3, 4,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 2, 4, 5, 3, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 2, 3, 4, 5, 6, 7,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 2, 4, 6, 8, 9, 7, 5, 3, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 4, 8 ,2, 6, 10, 11, 7, 3 ,9, 5, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 4, 8, 12, 16, 2, 6, 10, 14, 18, 19, 15, 11, 7, 3, 17, 13, 9, 5, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 8, 16, 2, 10, 18, 4, 12, 20, 6, 14, 22, 23, 15, 7, 21, 13, 5, 19,
    11, 3, 17, 9, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31
};

__constant short weight_unquant[12 * WEIGHT_QUANTIZE_NUM] = {
    0, 64,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 32, 64,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 21, 43, 64,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 16, 32, 48, 64,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 64, 12, 52, 25, 39,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 9, 18, 27, 37, 46, 55, 64,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 64, 7, 57, 14, 50, 21, 43, 28, 36,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 64, 17, 47, 5, 59, 23, 41, 11, 53, 28, 36,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 4, 8, 12, 17, 21, 25, 29, 35, 39, 43, 47, 52, 56, 60, 64,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 64, 16, 48, 3, 61, 19, 45, 6, 58, 23, 41, 9, 55, 26, 38, 13, 51, 29, 35,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 64, 8, 56, 16, 48, 24, 40, 2, 62, 11, 53, 19, 45, 27, 37, 5, 59, 13, 51, 22, 42, 30, 34,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 34, 36, 38,
    40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64
};

__constant short integer_from_trits[243] = {
    0, 1, 2, 4, 5, 6, 8, 9, 10,
    16, 17, 18, 20, 21, 22, 24, 25, 26,
    3, 7, 15, 19, 23, 27, 12, 13, 14,
    32, 33, 34, 36, 37, 38, 40, 41, 42,
    48, 49, 50, 52, 53, 54, 56, 57, 58,
    35, 39, 47, 51, 55, 59, 44, 45, 46,
    64, 65, 66, 68, 69, 70, 72, 73, 74,
    80, 81, 82, 84, 85, 86, 88, 89, 90,
    67, 71, 79, 83, 87, 91, 76, 77, 78,
    128, 129, 130, 132, 133, 134, 136, 137, 138,
    144, 145, 146, 148, 149, 150, 152, 153, 154,
    131, 135, 143, 147, 151, 155, 140, 141, 142,
    160, 161, 162, 164, 165, 166, 168, 169, 170,
    176, 177, 178, 180, 181, 182, 184, 185, 186,
    163, 167, 175, 179, 183, 187, 172, 173, 174,
    192, 193, 194, 196, 197, 198, 200, 201, 202,
    208, 209, 210, 212, 213, 214, 216, 217, 218,
    195, 199, 207, 211, 215, 219, 204, 205, 206,

    96, 97, 98, 100, 101, 102, 104, 105, 106,
    112, 113, 114, 116, 117, 118, 120, 121, 122,
    99, 103, 111, 115, 119, 123, 108, 109, 110,
    224, 225, 226, 228, 229, 230, 232, 233, 234,
    240, 241, 242, 244, 245, 246, 248, 249, 250,
    227, 231, 239, 243, 247, 251, 236, 237, 238,
    28, 29, 30, 60, 61, 62, 92, 93, 94,
    156, 157, 158, 188, 189, 190, 220, 221, 222,
    31, 63, 127, 159, 191, 255, 252, 253, 254
};

#define QUANT_MAX 21
__constant int bits_trits_quints_table[QUANT_MAX * 3] = {
    1, 0, 0, // RANGE_2
    0, 1, 0, // RANGE_3
    2, 0, 0, // RANGE_4
    0, 0, 1, // RANGE_5
    1, 1, 0, // RANGE_6
    3, 0, 0, // RANGE_8
    1, 0, 1, // RANGE_10
    2, 1, 0, // RANGE_12
    4, 0, 0, // RANGE_16
    2, 0, 1, // RANGE_20
    3, 1, 0, // RANGE_24
    5, 0, 0, // RANGE_32
    3, 0, 1, // RANGE_40
    4, 1, 0, // RANGE_48
    6, 0, 0, // RANGE_64
    4, 0, 1, // RANGE_80
    5, 1, 0, // RANGE_96
    7, 0, 0, // RANGE_128
    5, 0, 1, // RANGE_160
    6, 1, 0, // RANGE_192
    8, 0, 0 // RANGE_256
};

__constant short integer_from_quints[125] = {
    0, 1, 2, 3, 4, 8, 9, 10, 11, 12 ,16, 17, 18, 19, 20, 24, 25, 26, 27, 28, 5, 13 ,21, 29, 6,
    32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 48, 49, 50, 51, 52, 56, 57, 58, 59, 60, 37, 45, 53,
    61, 14,
    64, 65, 66, 67, 68, 72, 73, 74, 75, 76, 80, 81, 82, 83, 84, 88, 89, 90, 91, 92, 69, 77, 85,
    93, 22,
    96, 97, 98, 99, 100, 104, 105, 106, 107, 108, 112, 113, 114, 115, 116, 120, 121, 122, 123,
    124, 101, 109, 117, 125, 30,
    102, 103, 70, 71, 38, 110, 111, 78, 79, 46, 118, 119, 86, 87, 54, 126, 127, 94, 95, 62, 39,
    47, 55, 63, 31
};

__constant short color_quant_tables[21 * 256] = {
    // QUANT_2
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // QUANT_3
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    // QUANT_4
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    // QUANT_5
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    // QUANT_6
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // QUANT_8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    // QUANT_10
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // QUANT_12
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 7, 7, 7, 7, 7 ,7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // QUANT_16
    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    // QUANT_20
    0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
    19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 1, 1, 1, 1, 1,
    // QUANT_24
    0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 1, 1, 1, 1, 1,
    // QUANT_32
    0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2,
    2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6,
    6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10,
    10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13,
    14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
    16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17,
    18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19,
    19, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21,
    21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23,
    23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25,
    25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27,
    27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29,
    29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31,
    // QUANT_40
    0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 16, 16, 16, 16, 16, 16,
    16, 24, 24, 24, 24, 24, 24, 32, 32, 32, 32, 32, 32, 32, 2, 2,
    2, 2, 2, 2, 10, 10, 10, 10, 10, 10, 10, 18, 18, 18, 18, 18,
    18, 26, 26, 26, 26, 26, 26, 26, 34, 34, 34, 34, 34, 34, 4, 4,
    4, 4, 4, 4, 4, 12, 12, 12, 12, 12, 12, 20, 20, 20, 20, 20,
    20, 20, 28, 28, 28, 28, 28, 28, 36, 36, 36, 36, 36, 36, 36, 6,
    6, 6, 6, 6, 6, 14, 14, 14, 14, 14, 14, 14, 22, 22, 22, 22,
    22, 22, 30, 30, 30, 30, 30, 30, 30, 38, 38, 38, 38, 38, 38, 38,
    39, 39, 39, 39, 39, 39, 39, 31, 31, 31, 31, 31, 31, 31, 23, 23,
    23, 23, 23, 23, 15, 15, 15, 15, 15, 15, 15, 7, 7, 7, 7, 7,
    7, 37, 37, 37, 37, 37, 37, 37, 29, 29, 29, 29, 29, 29, 21, 21,
    21, 21, 21, 21, 21, 13, 13, 13, 13, 13, 13, 5, 5, 5, 5, 5,
    5, 5, 35, 35, 35, 35, 35, 35, 27, 27, 27, 27, 27, 27, 27, 19,
    19, 19, 19, 19, 19, 11, 11, 11, 11, 11, 11, 11, 3, 3, 3, 3,
    3, 3, 33, 33, 33, 33, 33, 33, 33, 25, 25, 25, 25, 25, 25, 17,
    17, 17, 17, 17, 17, 17, 9, 9, 9, 9, 9, 9, 1, 1, 1, 1,
    // QUANT_48
    0, 0, 0, 16, 16, 16, 16, 16, 16, 32, 32, 32, 32, 32, 2, 2,
    2, 2, 2, 18, 18, 18, 18, 18, 18, 34, 34, 34, 34, 34, 4, 4,
    4, 4, 4, 4, 20, 20, 20, 20, 20, 36, 36, 36, 36, 36, 6, 6,
    6, 6, 6, 6, 22, 22, 22, 22, 22, 38, 38, 38, 38, 38, 38, 8,
    8, 8, 8, 8, 24, 24, 24, 24, 24, 24, 40, 40, 40, 40, 40, 10,
    10, 10, 10, 10, 26, 26, 26, 26, 26, 26, 42, 42, 42, 42, 42, 12,
    12, 12, 12, 12, 12, 28, 28, 28, 28, 28, 44, 44, 44, 44, 44, 14,
    14, 14, 14, 14 ,14, 30, 30, 30, 30, 30, 46, 46, 46, 46, 46, 46,
    47, 47, 47, 47, 47, 47, 31, 31, 31, 31, 31, 15, 15, 15, 15, 15,
    15, 45, 45, 45, 45, 45, 29, 29, 29, 29, 29, 13, 13, 13, 13, 13,
    13, 43, 43, 43, 43, 43, 27, 27, 27, 27, 27, 27, 11, 11, 11, 11,
    11, 41, 41, 41, 41, 41, 25, 25, 25, 25, 25, 25, 9, 9, 9, 9,
    9, 39, 39, 39, 39, 39, 39, 23, 23, 23, 23, 23, 7, 7, 7, 7,
    7, 7, 37, 37, 37, 37, 37, 21, 21, 21, 21, 21, 5, 5, 5, 5,
    5, 5, 35, 35, 35, 35, 35, 19, 19, 19, 19, 19, 19, 3, 3, 3,
    3, 3, 33, 33, 33, 33, 33, 17, 17, 17, 17, 17, 17, 1, 1, 1,
    // QUANT_64
    0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4,
    4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8,
    8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12,
    12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16,
    16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19,
    20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23,
    24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27,
    28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31,
    32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35,
    36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39,
    40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43,
    44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47,
    47, 48, 48, 48, 48, 49, 49, 49, 49, 50, 50, 50, 50, 51, 51, 51,
    51, 52, 52, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 55, 55, 55,
    55, 56, 56, 56, 56, 57, 57, 57, 57, 58, 58, 58, 58, 59, 59, 59,
    59, 60, 60, 60, 60, 61, 61, 61, 61, 62, 62, 62, 62, 63, 63, 63,
    // QUANT_80
    0, 0, 16, 16, 16, 32, 32, 32, 48, 48, 48, 48, 64, 64, 64, 2,
    2, 2, 18, 18, 18, 34, 34, 34, 50, 50, 50, 50, 66, 66, 66, 4,
    4, 4, 20, 20, 20, 36, 36, 36, 36, 52, 52, 52, 68, 68, 68, 6,
    6, 6, 22, 22, 22, 38, 38, 38, 38, 54, 54, 54, 70, 70, 70, 8,
    8, 8, 24, 24, 24, 24, 40, 40, 40, 56, 56, 56, 72, 72, 72, 10,
    10, 10, 26, 26, 26, 26, 42, 42, 42, 58, 58, 58, 74, 74, 74, 12,
    12, 12, 12, 28, 28, 28, 44, 44, 44, 60, 60, 60, 76, 76, 76, 14,
    14, 14, 14, 30, 30, 30, 46, 46, 46, 62, 62, 62, 78, 78, 78, 78,
    79, 79, 79, 79, 63, 63, 63, 47, 47, 47, 31, 31, 31, 15, 15, 15,
    15, 77, 77, 77, 61, 61, 61, 45, 45, 45, 29, 29, 29, 13, 13, 13,
    13, 75, 75, 75, 59, 59, 59, 43, 43, 43, 27, 27, 27, 27, 11, 11,
    11, 73, 73, 73, 57, 57, 57, 41, 41, 41, 25, 25, 25, 25, 9, 9,
    9, 71, 71, 71, 55, 55, 55, 39, 39, 39, 39, 23, 23, 23, 7, 7,
    7, 69, 69, 69, 53, 53, 53, 37, 37, 37, 37, 21, 21, 21, 5, 5,
    5, 67, 67, 67, 51, 51, 51, 51, 35, 35, 35, 19, 19, 19, 3, 3,
    3, 65, 65, 65, 49, 49, 49, 49, 33, 33, 33, 17, 17, 17, 1, 1,
    // QUANT_96
    0, 0, 32, 32, 64, 64, 64, 2, 2, 2, 34, 34, 66, 66, 66, 4,
    4, 4, 36, 36, 68, 68, 68, 6, 6, 6, 38, 38, 70, 70, 70, 8,
    8, 8, 40, 40, 40, 72, 72, 10, 10, 10, 42, 42, 42, 74, 74, 12,
    12, 12, 44, 44, 44, 76, 76, 14, 14, 14, 46, 46, 46, 78, 78, 16,
    16, 16, 48, 48, 48, 80, 80, 80, 18, 18, 50, 50, 50, 82, 82, 82,
    20, 20, 52, 52, 52, 84, 84, 84, 22, 22, 54, 54, 54, 86, 86, 86,
    24, 24, 56, 56, 56, 88, 88, 88, 26, 26, 58, 58, 58, 90, 90, 90,
    28, 28, 60, 60, 60, 92, 92, 92, 30, 30, 62, 62, 62, 94, 94, 94,
    95, 95, 95, 63, 63, 63, 31, 31, 93, 93, 93, 61, 61, 61, 29, 29,
    91, 91, 91, 59, 59, 59, 27, 27, 89, 89, 89, 57, 57, 57, 25, 25,
    87, 87, 87, 55, 55, 55, 23, 23, 85, 85, 85, 53, 53, 53, 21, 21,
    83, 83, 83, 51, 51, 51, 19, 19, 81, 81, 81, 49, 49, 49, 17, 17,
    17, 79, 79, 47, 47, 47, 15, 15, 15, 77, 77, 45, 45, 45, 13, 13,
    13, 75, 75, 43, 43, 43, 11, 11, 11, 73, 73, 41, 41, 41, 9, 9,
    9, 71, 71, 71, 39, 39, 7, 7, 7, 69, 69, 69, 37, 37, 5, 5,
    5, 67, 67, 67, 35, 35, 3, 3, 3, 65, 65, 65, 33, 33, 1, 1,
    // QUANT_128
    0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7,
    8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15,
    16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23,
    24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31,
    32, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37, 37, 38, 38, 39, 39,
    40, 40, 41, 41, 42, 42, 43, 43, 44, 44, 45, 45, 46, 46, 47, 47,
    48, 48, 49, 49, 50, 50, 51, 51, 52, 52, 53, 53, 54, 54, 55, 55,
    56, 56, 57, 57, 58, 58, 59, 59, 60, 60, 61, 61, 62, 62, 63, 63,
    64, 64, 65, 65, 66, 66, 67, 67, 68, 68, 69, 69, 70, 70, 71, 71,
    72, 72, 73, 73, 74, 74, 75, 75, 76, 76, 77, 77, 78, 78, 79, 79,
    80, 80, 81, 81, 82, 82, 83, 83, 84, 84, 85, 85, 86, 86, 87, 87,
    88, 88, 89, 89, 90, 90, 91, 91, 92, 92, 93, 93, 94, 94, 95, 95,
    96, 96, 97, 97, 98, 98, 99, 99, 100, 100, 101, 101, 102, 102, 103, 103,
    104, 104, 105, 105, 106, 106, 107, 107, 108, 108, 109, 109, 110, 110, 111, 111,
    112, 112, 113, 113, 114, 114, 115, 115, 116, 116, 117, 117, 118, 118, 119, 119,
    120, 120, 121, 121, 122, 122, 123, 123, 124, 124, 125, 125, 126, 126, 127, 127,
    // QUANT_160
    0, 32, 32, 64, 96, 96, 128, 128, 2, 34, 34, 66, 98, 98, 130, 130,
    4, 36, 36, 68, 100, 100, 132, 132, 6, 38, 38, 70, 102, 102, 134, 134,
    8, 40, 40, 72, 104, 104, 136, 136, 10, 42, 42, 74, 106, 106, 138, 138,
    12, 44, 44, 76, 108, 108, 140, 140, 14, 46, 46, 78, 110, 110, 142, 142,
    16, 48, 48, 80, 112, 112, 144, 144, 18, 50, 50, 82, 114, 114, 146, 146,
    20, 52, 52, 84, 116, 116, 148, 148, 22, 54, 54, 86, 118, 118, 150, 150,
    24, 56, 56, 88, 120, 120, 152, 152, 26, 58, 58, 90, 122, 122, 154, 154,
    28, 60, 60, 92, 124, 124, 156, 156, 30, 62, 62, 94, 126, 126, 158, 158,
    159, 159, 127, 127, 95, 63, 63, 31, 157, 157, 125, 125, 93, 61, 61, 29,
    155, 155, 123, 123, 91, 59, 59, 27, 153, 153, 121, 121, 89, 57, 57, 25,
    151, 151, 119, 119, 87, 55, 55, 23, 149, 149, 117, 117, 85, 53, 53, 21,
    147, 147, 115, 115, 83, 51, 51, 19, 145, 145, 113, 113, 81, 49, 49, 17,
    143, 143, 111, 111, 79, 47, 47, 15, 141, 141, 109, 109, 77, 45, 45, 13,
    139, 139, 107, 107, 75, 43, 43, 11, 137, 137, 105, 105, 73, 41, 41, 9,
    135, 135, 103, 103, 71, 39, 39, 7, 133, 133, 101, 101, 69, 37, 37, 5,
    131, 131, 99, 99, 67, 35, 35, 3, 129, 129, 97, 97, 65, 33, 33, 1,
    // QUANT_192
    0, 64, 128, 128, 2, 66, 130, 130, 4, 68, 132, 132, 6, 70, 134, 134,
    8, 72, 136, 136, 10, 74, 138, 138, 12, 76, 140, 140, 14, 78, 142, 142,
    16, 80, 144, 144, 18, 82, 146, 146, 20, 84, 148, 148, 22, 86, 150, 150,
    24, 88, 152, 152, 26, 90, 154, 154, 28, 92, 156, 156, 30, 94, 158, 158,
    32, 96, 160, 160, 34, 98, 162, 162, 36, 100, 164, 164, 38, 102, 166, 166,
    40, 104, 168, 168, 42, 106, 170, 170, 44, 108, 172, 172, 46, 110, 174, 174,
    48, 112, 176, 176, 50, 114, 178, 178, 52, 116, 180, 180, 54, 118, 182, 182,
    56, 120, 184, 184, 58, 122, 186, 186, 60, 124, 188, 188, 62, 126, 190, 190,
    191, 191, 127, 63, 189, 189, 125, 61, 187, 187, 123, 59, 185, 185, 121, 57,
    183, 183, 119, 55, 181, 181, 117, 53, 179, 179, 115, 51, 177, 177, 113, 49,
    175, 175, 111, 47, 173, 173, 109, 45, 171, 171, 107, 43, 169, 169, 105, 41,
    167, 167, 103, 39, 165, 165, 101, 37, 163, 163, 99, 35, 161, 161, 97, 33,
    159, 159, 95, 31, 157, 157, 93, 29, 155, 155, 91, 27, 153, 153, 89, 25,
    151, 151, 87, 23, 149, 149, 85, 21, 147, 147, 83, 19, 145, 145, 81, 17,
    143, 143, 79, 15, 141, 141, 77, 13, 139, 139, 75, 11, 137, 137, 73, 9,
    135, 135, 71, 7, 133, 133, 69, 5, 131, 131, 67, 3, 129, 129, 65, 1,
    // QUANT_256
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
    64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
    80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
    96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
    112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
    128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
    144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
    160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
    176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
    192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
    208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
    224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
    240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255
};

__constant short color_unquant_tables[21][256] = {
    {
        0, 255
    },
    {
        0, 128, 255
    },
    {
        0, 85, 170, 255
    },
    {
        0, 64, 128, 192, 255
    },
    {
        0, 255, 51, 204, 102, 153
    },
    {
        0, 36, 73, 109, 146, 182, 219, 255
    },
    {
        0, 255, 28, 227, 56, 199, 84, 171, 113, 142
    },
    {
        0, 255, 69, 186, 23, 232, 92, 163, 46, 209, 116, 139
    },
    { // 16
        0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255
    },
    { // 20
        0, 255, 67, 188, 13, 242, 80, 175, 27, 228, 94, 161, 40, 215, 107, 148,
        54, 201, 121, 134
    },
    { // 24
        0, 255, 33, 222, 66, 189, 99, 156, 11, 244, 44, 211, 77, 178, 110, 145,
        22, 233, 55, 200, 88, 167, 121, 134
    },
    { // 32
        0, 8, 16, 24, 33, 41, 49, 57, 66, 74, 82, 90, 99, 107, 115, 123,
        132, 140, 148, 156, 165, 173, 181, 189, 198, 206, 214, 222, 231, 239, 247, 255
    },
    { // 40
        0, 255, 32, 223, 65, 190, 97, 158, 6, 249, 39, 216, 71, 184, 104, 151,
        13, 242, 45, 210, 78, 177, 110, 145, 19, 236, 52, 203, 84, 171, 117, 138,
        26, 229, 58, 197, 91, 164, 123, 132
    },
    { // 48
        0, 255, 16, 239, 32, 223, 48, 207, 65, 190, 81, 174, 97, 158, 113, 142,
        5, 250, 21, 234, 38, 217, 54, 201, 70, 185, 86, 169, 103, 152, 119, 136,
        11, 244, 27, 228, 43, 212, 59, 196, 76, 179, 92, 163, 108, 147, 124, 131
    },
    { // 64
        0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60,
        65, 69, 73, 77, 81, 85, 89, 93, 97, 101, 105, 109, 113, 117, 121, 125,
        130, 134, 138, 142, 146, 150, 154, 158, 162, 166, 170, 174, 178, 182, 186, 190,
        195, 199, 203, 207, 211, 215, 219, 223, 227, 231, 235, 239, 243, 247, 251, 255
    },
    { // 80
        0, 255, 16, 239, 32, 223, 48, 207, 64, 191, 80, 175, 96, 159, 112, 143,
        3, 252, 19, 236, 35, 220, 51, 204, 67, 188, 83, 172, 100, 155, 116, 139,
        6, 249, 22, 233, 38, 217, 54, 201, 71, 184, 87, 168, 103, 152, 119, 136,
        9, 246, 25, 230, 42, 213, 58, 197, 74, 181, 90, 165, 106, 149, 122, 133,
        13, 242, 29, 226, 45, 210, 61, 194, 77, 178, 93, 162, 109, 146, 125, 130
    },
    { // 96
        0, 255, 8, 247, 16, 239, 24, 231, 32, 223, 40, 215, 48, 207, 56, 199,
        64, 191, 72, 183, 80, 175, 88, 167, 96, 159, 104, 151, 112, 143, 120, 135,
        2, 253, 10, 245, 18, 237, 26, 229, 35, 220, 43, 212, 51, 204, 59, 196,
        67, 188, 75, 180, 83, 172, 91, 164, 99, 156, 107, 148, 115, 140, 123, 132,
        5, 250, 13, 242, 21, 234, 29, 226, 37, 218, 45, 210, 53, 202, 61, 194,
        70, 185, 78, 177, 86, 169, 94, 161 ,102, 153, 110, 145, 118, 137, 126, 129 
    },
    { // 128
        0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,
        32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62,
        64, 66, 68, 70, 72, 74, 76 ,78, 80, 82, 84, 86, 88, 90, 92, 94,
        96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126,
        129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159,
        161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191,
        193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223,
        225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251, 253, 255

    },
    { // 160
        0, 255, 8, 247, 16, 239, 24, 231, 32, 223, 40, 215, 48, 207, 56, 199,
        64, 191, 72, 183, 80, 175, 88, 167, 96, 159, 104, 151, 112, 143, 120, 135,
        1, 254, 9, 246, 17, 238, 25, 230, 33, 222, 41, 214, 49, 206, 57, 198,
        65, 190, 73, 182, 81, 174, 89, 166, 97, 158, 105, 150, 113, 142, 121, 134,
        3, 252, 11, 244, 19, 236, 27, 228, 35, 220, 43, 212, 51, 204, 59, 196,
        67, 188, 75, 180, 83, 172, 91, 164, 99, 156, 107, 148, 115, 140, 123, 132,
        4, 251, 12, 243, 20, 235, 28, 227, 36, 219, 44, 211, 52, 203, 60, 195,
        68, 187, 76, 179, 84, 171, 92, 163, 100, 155, 108, 147, 116, 139, 124, 131,
        6, 249, 14, 241, 22, 233, 30, 225, 38, 217, 46, 209, 54, 201, 62, 193,
        70, 185, 78, 177, 86, 169, 94, 161, 102, 153, 110, 145, 118, 137, 126, 129
    },
    {
        0, 255, 4, 251, 8, 247, 12, 243, 16, 239, 20, 235, 24, 231, 28, 227,
        32, 223, 36, 219, 40, 215, 44, 211, 48, 207, 52, 203, 56, 199, 60, 195,
        64, 191, 68, 187, 72, 183, 76, 179, 80, 175, 84, 171, 88, 167, 92, 163,
        96, 159, 100, 155, 104, 151, 108, 147, 112, 143, 116, 139, 120, 135, 124, 131,
        1, 254, 5, 250, 9, 246, 13, 242, 17, 238, 21, 234, 25, 230, 29, 226,
        33, 222, 37, 218, 41, 214, 45, 210, 49, 206, 53, 202, 57, 198, 61, 194,
        65, 190, 69, 186, 73, 182, 77, 178, 81, 174, 85, 170, 89, 166, 93, 162,
        97, 158, 101, 154, 105, 150, 109, 146, 113, 142, 117, 138, 121, 134, 125, 130,
        2, 253, 6, 249, 10, 245, 14, 241, 18, 237, 22, 233, 26, 229, 30, 225,
        34, 221, 38, 217, 42, 213, 46, 209, 50, 205, 54, 201, 58, 197, 62, 193,
        66, 189, 70, 185, 74, 181, 78, 177, 82, 173, 86, 169, 90, 165, 94, 161,
        98, 157, 102, 153, 106, 149, 110, 145, 114, 141, 118, 137, 122, 133, 126, 129
    },
    {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
        32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
        64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
        96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
        112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
        128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
        144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
        160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
        176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
        192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
        208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
        224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
        240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255
    }
};


void swap(float4* lhs, float4* rhs)
{
    float4 tmp = *lhs;
    *lhs = *rhs;
    *rhs = tmp;
}

void find_min_max(float4* texels, float4 pt_mean, float4 vec_k, float4* e0, float4* e1,bool has_alpha)
{
    float a = 1e31f;
    float b = -1e31f;
    for(int i=0; i<BLOCK_SIZE; ++i)
    {
        float t = dot(texels[i] - pt_mean, vec_k);
        a = min(a,t);
        b = max(b,t);
    }

    *e0 = clamp(vec_k *a + pt_mean, 0.0f, 255.0f);
    *e1 = clamp(vec_k* b + pt_mean, 0.0f, 255.0f );
    // if the direction_vector ends up pointing from light to dark, FLIP IT!
    //this will make the endpoint the darkest one;
    float4 e0u = round(*e0);
    float4 e1u = round(*e1);
    if(e0u.x + e0u.y + e0u.z > e1u.x + e1u.y + e1u.z  )
    {
        swap(e0,e1);
    }
    if (!has_alpha) {
    (*e0).w = 255.0f;
    (*e1).w = 255.0f;   
    }
}

void max_accumulation_pixel_direction(float4* texels, float4 pt_mean,float4* e0, float4* e1,bool has_alpha)
{
    int i=0;
    
    float4 sum_r = (float4)(0);
    float4 sum_g = (float4)(0);
    float4 sum_b = (float4)(0);
    float4 sum_a = (float4)(0);
    for(i=0; i < BLOCK_SIZE; ++i)
    {
        float4 dt = texels[i] - pt_mean;
        sum_r += (dt.x > 0.0f) ? dt : (float4)(0);
        sum_g += (dt.y > 0.0f) ? dt : (float4)(0);
        sum_b += (dt.z > 0.0f) ? dt : (float4)(0);
        sum_a += (dt.w > 0.0f) ? dt : (float4)(0);
    }
    float dot_r = dot(sum_r, sum_r);
    float dot_g = dot(sum_g, sum_g);
    float dot_b = dot(sum_b, sum_b);
    float dot_a = dot(sum_a, sum_a);

    float maxdot = dot_r;
    float4 vec_k = sum_r;

    if (dot_g > maxdot)
    {
        vec_k = sum_g;
        maxdot = dot_g;
    } 
 
    if (dot_b > maxdot)
    {
        vec_k = sum_b;
        maxdot = dot_b;
    } 
   
    if (has_alpha && dot_a > maxdot)
    {
        vec_k = sum_a;
        maxdot = dot_a;
    }

    // safe normalize
    float lenk = length(vec_k);
    vec_k = (lenk < SMALL_VALUE) ? vec_k : normalize(vec_k);
     
    find_min_max(texels,pt_mean, vec_k, e0, e1,has_alpha);
} 
void encode_color_normal(short quant_level, float4 e0,float4 e1,short* endpoint_quantized)
{
    int4 e0q = (int4)((int)(round(e0.x)), (int)(round(e0.y)),(int)(round(e0.z)),(int)(round(e0.w)));    
    int4 e1q = (int4)((int)(round(e1.x)), (int)(round(e1.y)),(int)(round(e1.z)),(int)(round(e1.w)));
    
    endpoint_quantized[0] = color_quant_tables[quant_level * 256 + e0q.x];
    endpoint_quantized[1] = color_quant_tables[quant_level * 256 + e1q.x];
    endpoint_quantized[2] = color_quant_tables[quant_level * 256 + e0q.y];
    endpoint_quantized[3] = color_quant_tables[quant_level * 256 + e1q.y];
    endpoint_quantized[4] = color_quant_tables[quant_level * 256 + e0q.z];
    endpoint_quantized[5] = color_quant_tables[quant_level * 256 + e1q.z];
    endpoint_quantized[6] = color_quant_tables[quant_level * 256 + e0q.w];
    endpoint_quantized[7] = color_quant_tables[quant_level * 256 + e1q.w];
}

void decode_color(short quant_level, short endpoint_quantized[8], float4* e0, float4* e1)
{
    (*e0).x = (float)(color_unquant_tables[quant_level][endpoint_quantized[0]]);
    (*e1).x = (float)(color_unquant_tables[quant_level][endpoint_quantized[1]]);
    (*e0).y = (float)(color_unquant_tables[quant_level][endpoint_quantized[2]]);
    (*e1).y = (float)(color_unquant_tables[quant_level][endpoint_quantized[3]]);
    (*e0).z = (float)(color_unquant_tables[quant_level][endpoint_quantized[4]]);
    (*e1).z = (float)(color_unquant_tables[quant_level][endpoint_quantized[5]]);
    (*e0).w = (float)(color_unquant_tables[quant_level][endpoint_quantized[6]]);
    (*e1).w = (float)(color_unquant_tables[quant_level][endpoint_quantized[7]]);
}
 
//calculate quantize weights
short quantize_weight(uint weight_range, float weight)
{
    short q = (short)(round(weight* (float)(weight_range)));
    return clamp(q, (short)(0),(short)(weight_range));
}

float unquantize_weight(uint weight_range, uint qw)
{
    float w = 1.0f * (float)(qw) / (float)(weight_range);
    return clamp(w,0.0f,1.0f);
}

float4 samp_texel(float4 texels[BLOCK_SIZE], uint4 index,float4 coff)
{
    float4 sum = texels[index.x] * coff.x;
    sum += texels[index.y] * coff.y;
    sum += texels[index.z] * coff.z;
    sum += texels[index.w] * coff.w;
    return sum;
}

void calculate_normal_weights_2plane(float4* texels, 
    float4 ep0, float4 ep1, int component_plane2,float* projw)
{
    int i=0;
    float4 vec_k = ep1-ep0;
    if (length(vec_k) < SMALL_VALUE)
    {
        for (i=0; i< 2 * X_GRIDS * Y_GRIDS; ++i)
        {
            projw[i] = 0.0f;
        }
    }
    else
    {
        float minw = 1e31f;
        float maxw = -1e31f;
        float minwp = 1e31f;
        float maxwp = -1e31f;
        if(component_plane2 == 0) {
            vec_k = normalize((float4)(0, vec_k.y, vec_k.z, vec_k.w));
        } else if (component_plane2 == 1){
            vec_k = normalize((float4)(vec_k.x, 0, vec_k.z, vec_k.w));
        } else if (component_plane2 == 2){
            vec_k = normalize((float4)(vec_k.x,vec_k.y , 0, vec_k.w));
        } else if (component_plane2 == 3){
            vec_k = normalize((float4)(vec_k.x,vec_k.y , vec_k.z, 0));
        }
        for (i = 0; i < BLOCK_SIZE; ++i) 
        {
            float4 texel = texels[i];
            float w = dot(vec_k, texel - ep0);
            minw  = min(w,minw);
            maxw = max(w, maxw);
            projw[2*i] = w;
             
            float wp  = texel.x - ep0.x;
            if (component_plane2 == 1) {
                wp = texel.y - ep0.y;
            } else if (component_plane2 == 2) {
               wp = texel.z - ep0.z;   
           } else if (component_plane2 == 3) {
               wp = texel.w - ep0.w; 
          }
          minwp = min(wp,minwp);
          maxwp = max(wp,maxwp);
          projw[2*i+1] = wp;
          }
          float invlen = maxw - minw;
          float invlenp = maxwp - minwp;
          invlen = max(SMALL_VALUE,invlen);
          invlen = 1.0f /invlen;
          invlenp = max(SMALL_VALUE,invlenp);
          invlenp = 1.0f / invlenp;
          for (i=0 ;i<X_GRIDS * Y_GRIDS; ++i)                      
          {
              projw[2*i] = (projw[2*i] - minw) * invlen;
              projw[2*i+1] = (projw[2*i+1] - minwp) * invlenp;
          }
    }
}
void calculate_normal_weights(int part, PartInfo* part_info, float4* texels, float4 ep0, float4 ep1, float* projw)
{
    int i=0;
    float4 vec_k = ep1 - ep0;
    if (length(vec_k) < SMALL_VALUE && !part_info)
    {
        for (i=0; i<X_GRIDS * Y_GRIDS; ++i)
            {
                projw[i] = 0.0f;
            }
    }
    else 
    {
        vec_k = normalize(vec_k);
        float minw = 1e31f;
        float maxw = -1e31f;
        for (i=0; i < BLOCK_SIZE; ++i)
        {
            if(!part_info){
                float w = dot(vec_k,texels[i] - ep0);
                minw = min(w, minw);
                maxw = max(w, maxw);
                projw[i] = w;
            } else {
                int cur_part = get_part(part_info, i);
                if (cur_part == part) {
                    float w = dot(vec_k, texels[i] - ep0);
                    minw = min(w, minw);
                    maxw = max(w, maxw);
                    projw[i] = w;
                }
            }
        }
    float invlen = maxw - minw;
    invlen = max(SMALL_VALUE, invlen );
    invlen = 1.0f / invlen;
     for (i=0 ;i<X_GRIDS * Y_GRIDS; ++i)                     
          {
              if (!part_info) {
                projw[i] = (projw[i] - minw) * invlen;   
              } else {
                  int cur_part = get_part(part_info, i);
                  if(cur_part  == part) {
                      projw[i] = (projw[i] - minw) * invlen; 
                  }
              } 
          }
      }
}
 
void quantize_weights_rgb(float projw[2 * X_GRIDS * Y_GRIDS], uint weight_range, short* weights)
{
    for (int i = 0;i < 2 * X_GRIDS * Y_GRIDS; ++i) 
    {
        weights[i] = quantize_weight(weight_range, projw[i]);
    }         
}

void calculate_quantized_weights_2plane(float4* texels,
uint weight_range,
float4 ep0,
float4 ep1,
short* weights,
int component_plane2)
{
    float projw[2 * X_GRIDS * Y_GRIDS];
    calculate_normal_weights_2plane(texels, ep0, ep1, component_plane2, projw);
    quantize_weights_rgb(projw, weight_range, weights);
    return;
}
 
void quantize_weights(float projw[X_GRIDS * Y_GRIDS], uint weight_range, short* weights)
{
    for (int i = 0;i < X_GRIDS * Y_GRIDS; ++i) 
    {
        weights[i] = quantize_weight(weight_range, projw[i]);
    }         
}
 
void calculate_quantized_weights(float4* texels, uint weight_range, float4 ep0, float4 ep1, short* weights) 
{
    float projw[X_GRIDS * Y_GRIDS];
    calculate_normal_weights(0,NULL, texels, ep0, ep1,projw);
    quantize_weights(projw, weight_range, weights);
}

void orbits8_ptr(uint4* outputs, uint* bitoffset, uint number, uint bitcount)
{
    uint newpos = *bitoffset + bitcount;
   
    uint nidx = newpos >>5;
    uint uidx = *bitoffset >>5;
    uint bit_idx = *bitoffset & 31u;
    if( uidx == 0){
        (*outputs).x | = (number <<bit_idx);
        (*outputs).y | = (nidx >uidx) ? (number >>(32u - bit_idx)) :0u;
    } else if (uidx == 1) {
        (*outputs).y | = (number <<bit_idx);
        (*outputs).z | = (nidx >uidx) ? (number >>(32u - bit_idx)) :0u;
    } else if (uidx == 2){
        (*outputs).z | = (number <<bit_idx);
        (*outputs).w | = (nidx >uidx) ? (number >>(32u - bit_idx)) :0u;
    } else if (uidx == 3){
    }
    *bitoffset = newpos;
}

void split_high_low(uint n,uint i, int* high, uint* low)
{
    uint low_mask = (1u << i) - 1u;
    *low = n & low_mask;
    *high = (int)(n >> i) & 0xFF;
}

uint reverse_byte(uint p)
{
    p = ((p & 0xFu) << 4) | ((p >> 4) & 0xFu);
    p = ((p & 0x33u) << 2) | ((p >> 2) & 0x33u);
    p = ((p & 0x55u) << 1) | ((p >> 1) & 0x55u);
    return p;
}

void encode_trits(uint bitcount,
uint b0, uint b1, uint b2, uint b3, uint b4,
uint4* outputs, uint* outpos)
{
    int t0, t1, t2, t3, t4;
    uint m0, m1, m2, m3, m4;
    split_high_low(b0,bitcount, &t0, &m0);
    split_high_low(b1,bitcount, &t1, &m1);
    split_high_low(b2,bitcount, &t2, &m2);
    split_high_low(b3,bitcount, &t3, &m3);
    split_high_low(b4,bitcount, &t4, &m4);  

    ushort packhigh = (ushort)(integer_from_trits[t4 * 81 + t3 * 27 + t2 * 9 + t1* 3 + t0]);
    orbits8_ptr(outputs, outpos, m0, bitcount);
    orbits8_ptr(outputs, outpos,packhigh & 3u, 2u);
    
    orbits8_ptr(outputs, outpos, m1, bitcount);
    orbits8_ptr(outputs, outpos,(packhigh >> 2) & 3u, 2u);

    orbits8_ptr(outputs, outpos, m2, bitcount);
    orbits8_ptr(outputs, outpos,(packhigh >> 4) & 1u, 1u);

    orbits8_ptr(outputs, outpos, m3, bitcount);
    orbits8_ptr(outputs, outpos,(packhigh >> 5) & 3u, 2u);

    orbits8_ptr(outputs, outpos, m4, bitcount);
    orbits8_ptr(outputs, outpos,(packhigh >> 7) & 1u, 1u);
}

void encode_quints(uint bitcount, uint b0, uint b1, uint b2, uint4* outputs, uint* outpos) 
{
    int q0, q1, q2;
    uint m0, m1,m2;

    split_high_low(b0,bitcount, &q0, &m0);
    split_high_low(b1,bitcount, &q1, &m1);
    split_high_low(b2,bitcount, &q2, &m2);

    ushort packhigh = (ushort)(integer_from_quints[q2 * 25 + q1 * 5 + q0]);

    orbits8_ptr(outputs, outpos, m0, bitcount);
    orbits8_ptr(outputs, outpos,packhigh & 7u, 3u);

    orbits8_ptr(outputs, outpos, m1, bitcount);
    orbits8_ptr(outputs, outpos,(packhigh >> 3) & 3u, 2u);

    orbits8_ptr(outputs, outpos, m2, bitcount);
    orbits8_ptr(outputs, outpos,(packhigh >> 5) & 3u, 2u);
}

void bise_endpoints(short numbers[8], int range, uint4* outputs,bool has_alpha, uint* bitpos)
{
    uint bits = (uint)(bits_trits_quints_table[range * 3 + 0]);
    uint trits = (uint)(bits_trits_quints_table[range * 3 + 1]);
    uint quints = (uint)(bits_trits_quints_table[range * 3 + 2]);

    uint count  = has_alpha ? 8u : 6u;

    if(trits == 1u)
    {
        encode_trits(bits, numbers[0], numbers[1], numbers[2],numbers[3],numbers[4], outputs, bitpos);
        encode_trits(bits, numbers[5], numbers[6], numbers[7],0u, 0u, outputs, bitpos);
        *bitpos = ((8u + 5u * bits) * count + 4u) / 5u;
    }
    else if (quints == 1u)
    {
        encode_quints(bits, numbers[0], numbers[1], numbers[2], outputs, bitpos);
        encode_quints(bits, numbers[3], numbers[4], numbers[5], outputs, bitpos);
        encode_quints(bits, numbers[6], numbers[7], 0u, outputs, bitpos);
        *bitpos = ((7u + 3u * bits) * count + 2u) / 3u;
    }
    else
    {
        for(uint i = 0u; i < count; ++i)
        {
            orbits8_ptr(outputs, bitpos, numbers[i], bits);
        }
    }
}

void bise_weights(short numbers[16], int range, uint4* outputs)
{
    uint bitpos = 0u;
    uint bits = (uint)(bits_trits_quints_table[range * 3 + 0]);
    uint trits = (uint)(bits_trits_quints_table[range * 3 + 1]);
    uint quints = (uint)(bits_trits_quints_table[range * 3 + 2]);

    if(trits == 1u)
    {
        encode_trits(bits,numbers[0], numbers[1], numbers[2],numbers[3],numbers[4], outputs, &bitpos);
        encode_trits(bits,numbers[5], numbers[6], numbers[7],numbers[8],numbers[9], outputs, &bitpos);
        encode_trits(bits,numbers[10], numbers[11], numbers[12],numbers[13],numbers[14], outputs, &bitpos);
        encode_trits(bits,numbers[15], 0u, 0u, 0u, 0u,outputs, &bitpos);
        bitpos = ((8u + 5u * bits) * 16u + 4u ) / 5u;
    }
    else if(quints == 1u)
    {
        encode_quints(bits,numbers[0], numbers[1], numbers[2], outputs, &bitpos);
        encode_quints(bits,numbers[3], numbers[4], numbers[5], outputs, &bitpos);
        encode_quints(bits,numbers[6], numbers[7], numbers[8], outputs, &bitpos);
        encode_quints(bits,numbers[9], numbers[10], numbers[11], outputs, &bitpos);
        encode_quints(bits,numbers[12], numbers[13], numbers[14], outputs, &bitpos);
        encode_quints(bits,numbers[15], 0u, 0u, outputs, &bitpos);
        bitpos = ((7u + 3u * bits) * 16u + 2u ) / 3u;   
    }
    else 
    {
        for(int i=0; i < 16; ++i)
        {
            orbits8_ptr(outputs, &bitpos, numbers[i], bits);    
        }
    }
}

uint bise_weights_2plane(short numbers[32], int range, uint4* outputs)
{
    uint bitpos = 0u;
    uint bits = (uint)(bits_trits_quints_table[range * 3 + 0]);
    uint trits = (uint)(bits_trits_quints_table[range * 3 + 1]);
    uint quints = (uint)(bits_trits_quints_table[range * 3 + 2]);

    if(trits == 1u)
    {
        encode_trits(bits,numbers[0], numbers[1], numbers[2], numbers[3], numbers[4], outputs, &bitpos);
        encode_trits(bits,numbers[5], numbers[6], numbers[7], numbers[8], numbers[9], outputs, &bitpos);
        encode_trits(bits,numbers[10], numbers[11], numbers[12], numbers[13], numbers[14], outputs, &bitpos);
        encode_trits(bits,numbers[15], numbers[16], numbers[17], numbers[18], numbers[19], outputs, &bitpos);
        encode_trits(bits,numbers[20], numbers[21], numbers[22], numbers[23], numbers[24], outputs, &bitpos);
        encode_trits(bits,numbers[25], numbers[26], numbers[27], numbers[28], numbers[29], outputs, &bitpos);
        encode_trits(bits,numbers[30], numbers[31], 0u,0u,0u, outputs, &bitpos);
        bitpos = ((8u + 5u * bits) * 32u + 4u ) / 5u;
        
    }
    else if(quints == 1u)
    {
        encode_quints(bits, numbers[0], numbers[1], numbers[2], outputs, &bitpos);
        encode_quints(bits, numbers[3], numbers[4], numbers[5], outputs, &bitpos);
        encode_quints(bits, numbers[6], numbers[7], numbers[8], outputs, &bitpos);
        encode_quints(bits, numbers[9], numbers[10], numbers[11], outputs, &bitpos);
        encode_quints(bits, numbers[12], numbers[13], numbers[14], outputs, &bitpos);
        encode_quints(bits, numbers[15], numbers[16], numbers[17], outputs, &bitpos);
        encode_quints(bits, numbers[18], numbers[19], numbers[20], outputs, &bitpos);
        encode_quints(bits, numbers[21], numbers[22], numbers[23], outputs, &bitpos);
        encode_quints(bits, numbers[24], numbers[25], numbers[26], outputs, &bitpos);
        encode_quints(bits, numbers[27], numbers[28], numbers[29], outputs, &bitpos);
        encode_quints(bits, numbers[30], numbers[31], 0u, outputs, &bitpos);
        bitpos = ((7u + 3u * bits) * 32u + 2u ) / 3u;    
    }
    else
    {
        for(int i = 0; i < 32; ++i)
        {
            orbits8_ptr(outputs,&bitpos, numbers[i], bits);    
        }
    }
    return bitpos;
}

uint4 assemble_block(uint blockmode, uint color_endpoint_mode,
uint partition_count,uint partition_index, uint4 ep_ise, uint4 wt_ise)
{
    uint4 phy_blk = (uint4)(0, 0, 0, 0);
    phy_blk.w |= reverse_byte(wt_ise.x & 0xFFu) << 24;
    phy_blk.w |= reverse_byte((wt_ise.x >> 8) & 0xFFu) << 16;
    phy_blk.w |= reverse_byte((wt_ise.x >> 16) & 0xFFu) << 8;
    phy_blk.w |= reverse_byte((wt_ise.x >> 24) & 0xFFu);

    phy_blk.z |= reverse_byte(wt_ise.y & 0xFFu) << 24;
    phy_blk.z |= reverse_byte((wt_ise.y >> 8) & 0xFFu) << 16;
    phy_blk.z |= reverse_byte((wt_ise.y >> 16) & 0xFFu) << 8;
    phy_blk.z |= reverse_byte((wt_ise.y >> 24) & 0xFFu);

    phy_blk.y |= reverse_byte(wt_ise.z & 0xFFu) << 24;
    phy_blk.y |= reverse_byte((wt_ise.z >> 8) & 0xFFu) << 16;
    phy_blk.y |= reverse_byte((wt_ise.z >> 16) & 0xFFu) << 8;
    phy_blk.y |= reverse_byte((wt_ise.z >> 24) & 0xFFu);

    phy_blk.x = blockmode;

    if(partition_count > 1u)
    {
        uint endpoint_offset = 29u;
        uint cem_bits = 6u;
        uint bitpos = 11u;
        orbits8_ptr(&phy_blk, &bitpos, partition_count - 1u, 2u);
        orbits8_ptr(&phy_blk, &bitpos, partition_index & 63u, 6u);
        orbits8_ptr(&phy_blk, &bitpos, partition_index >> 6, 4u);
        orbits8_ptr(&phy_blk, &bitpos, color_endpoint_mode << 2, 6u);
        
        phy_blk.x |= (ep_ise.x & 0x7u) << 29;
        phy_blk.y |= ((ep_ise.x >> 3) & 0x1FFFFFFFu);
        phy_blk.y |= (ep_ise.y & 0x7u) <<29;
        phy_blk.z |= ((ep_ise.y >> 3) & 0x1FFFFFFFu);
    } else {
        phy_blk.x |= (color_endpoint_mode & 0xFu) << 13;
        phy_blk.x |= (ep_ise.x & 0x7FFFu) << 17;
        phy_blk.y |= ((ep_ise.x >> 15) & 0x1FFFFu);
        phy_blk.y |= (ep_ise.y & 0x7FFFu) << 17;
        phy_blk.z |= ((ep_ise.y >> 15) & 0x1FFFFu);
    }

    return phy_blk;    
}

uint assemble_blockmode(uint weight_quantmethod, bool is_dual_plane)
{
    uint a = (uint)((Y_GRIDS - 2) & 0x3);
    uint b = (uint)((X_GRIDS - 4) & 0x3);

    uint d = is_dual_plane ? 1u : 0u;

    uint h = (weight_quantmethod < 6u) ? 0u : 1u;
    uint r = (weight_quantmethod % 6u) + 2u;

    uint blockmode = (r >> 1) & (uint)(0x3);
    blockmode |= (r & (uint)(0x1)) << 4u;
    blockmode |= (a & (uint)(0x3)) << 5u;
    blockmode |= (b & (uint)(0x3)) << 7u;
    blockmode |= h << 9u;
    blockmode |= d << 10u;
    return blockmode;
}

uint4 endpoint_ise(float4* ep0, float4* ep1,short endpoint_quantmethod,bool has_alpha)
{
    short ep_quantized[8];
    encode_color_normal(endpoint_quantmethod, *ep0, *ep1, ep_quantized);
    decode_color(endpoint_quantmethod, ep_quantized, ep0, ep1);

    if(!has_alpha){
        ep_quantized[6] = 0;
        ep_quantized[7] = 0;
    }

    uint4 ep_ise = (uint4)(0);
    uint bitpos = 0u;
    bise_endpoints(ep_quantized, endpoint_quantmethod, &ep_ise, has_alpha, &bitpos);
    return ep_ise;
}

float4 cal_texel(short weight, float4 ep0, float4 ep1){
    short weight0 = 64 -  weight;
    return (ep0 * weight0 + ep1 * weight) / 64.0f;
}

uint4 weight_ise_2plane(float4* texels, uint weight_range, float4 ep0,
    float4 ep1, short weight_quantmethod,int component_plane2, float* errval)
{
    int i = 0;
    short wt_quantized[2 * X_GRIDS * Y_GRIDS];
    calculate_quantized_weights_2plane(texels, weight_range, ep0, ep1, wt_quantized, component_plane2);
    float sum_err = 0.0f;
    for(i = 0; i < 2 * X_GRIDS * Y_GRIDS; ++i)
    {
        short w = weight_quantmethod * WEIGHT_QUANTIZE_NUM + wt_quantized[i];
        wt_quantized[i] = scramble_table[w];
        bool odd = (i % 2 == 1);
        if (odd) {
            short w_even = weight_quantmethod * WEIGHT_QUANTIZE_NUM + wt_quantized[i - 1];
            w = weight_quantmethod * WEIGHT_QUANTIZE_NUM + wt_quantized[i];
            short wt = weight_unquant[w_even];
            short wt1 = weight_unquant[w];
            float4 new_texel = cal_texel(wt, ep0, ep1);
            float4 tex = cal_texel(wt1, ep0, ep1);
            if(component_plane2 == 0) {
                new_texel.x = tex.x;
            } else if(component_plane2 == 1) {
                new_texel.y = tex.y;
            } else if(component_plane2 == 2) {
                new_texel.z = tex.z;
            } else if(component_plane2 == 3) {
                new_texel.w = tex.w;
            }
            float4 curTexel = texels[i >> 2];
            float4 diff = new_texel - curTexel;
            sum_err += dot(diff,diff);
        }
    }
    *errval = sum_err;

    uint4 wt_ise = (uint4)(0);
    uint bitpos = bise_weights_2plane(wt_quantized, (int)(weight_quantmethod),&wt_ise);
    component_plane2 = ((component_plane2 >> 1) & 0x3) | ((component_plane2 << 1) & 0x3);
    orbits8_ptr(&wt_ise, &bitpos, (uint)(component_plane2), 2u);
    return wt_ise;
}
uint4 weight_ise(float4* texels,uint weight_range, float4 ep0, float4 ep1,short weight_quantmethod, float* errval)
{
    int i = 0;
    short wt_quantized[X_GRIDS * Y_GRIDS];
    calculate_quantized_weights(texels, weight_range, ep0, ep1, wt_quantized);

    float sum_err = 0.0f;
    for(i = 0; i < X_GRIDS * Y_GRIDS; ++i)
    {
        short w = weight_quantmethod * WEIGHT_QUANTIZE_NUM + wt_quantized[i];
        wt_quantized[i] = scramble_table[w];
        w = weight_quantmethod * WEIGHT_QUANTIZE_NUM +  wt_quantized[i];
        short wt = weight_unquant[w];
        float4 new_texel = cal_texel(wt, ep0, ep1);
        float4 diff = new_texel - texels[i];
        sum_err += dot(diff,diff);
    }
    *errval = sum_err;
    uint4 wt_ise = (uint4)(0);
    bise_weights(wt_quantized, (int)(weight_quantmethod), &wt_ise);
    return wt_ise;
}
uint hash52(uint inp){
    inp ^= inp >> 15;

    inp *= 0xEEDE0891u;
    inp ^= (inp >> 5) & 0x7FFFFFFu;
    inp += inp << 16;
    inp ^= (inp >> 7) & 0x1FFFFFFu;
    inp ^= (inp >> 3) & 0x1FFFFFFFu;
    inp ^= inp << 6; 
    inp ^= (inp >> 17) & 0x7FFFu;
    return inp;   
}
__constant float cluster_cutoffs[9] = {
    0.626220f, 0.932770f, 0.275454f,
    0.318558f, 0.240113f, 0.009190f,
    0.347661f, 0.731960f, 0.156391f
};

float try_encode(float4* texels, float4 texels_mean, bool has_alpha, int dual_plane_component,
uint4* ep_ise, uint4* wt_ise, short3* best_blockmode) {
    float errval;
    if(has_alpha) {
        *best_blockmode = (short3)(QUANT_6, QUANT_256, 6);
    } else {
        *best_blockmode = (short3)(QUANT_12, QUANT_256, 12);
    }
    short weight_quantmethod = (*best_blockmode).x;
    short endpoint_quantmethod = (*best_blockmode).y;
    short weight_range = (*best_blockmode).z;

    float4 ep0,ep1;
    max_accumulation_pixel_direction(texels, texels_mean, &ep0, &ep1, has_alpha);

    *ep_ise = endpoint_ise(&ep0, &ep1, endpoint_quantmethod, has_alpha);
    *wt_ise = weight_ise(texels, weight_range - 1u,ep0, ep1, weight_quantmethod, &errval);
        return errval;
}

uint4 encode_block(float4* texels, float4 texels_mean,
    int blockID, __global PartInfo* global_parts, __global uint* errs)
{
    bool has_alpha = true ;
    bool is_dual_plane = false;
    float errval = 10000000.0f;
    float tmp_err_val;
    int part_count = 1;
    int part_index = 0;

    uint4 ep_ise, wt_ise, tmp_ep_ise, tmp_wt_ise;
    short3 best_blockmode, tmp_best_blockmode;
    float threshhold = 10000.0f;
    errval = try_encode(texels,texels_mean,
        has_alpha, 0 ,&ep_ise, &wt_ise, &best_blockmode);

    uint blockmode = assemble_blockmode(best_blockmode.x,is_dual_plane);
    uint color_endpoint_mode;
    if(has_alpha) {
        color_endpoint_mode = CEM_LDR_RGBA_DIRECT;
    } else {
        color_endpoint_mode = CEM_LDR_RGB_DIRECT;        
    }
    errs[blockID] = (uint)(errval);
    return assemble_block(blockmode, color_endpoint_mode, (uint)(part_count), (uint)(part_index), ep_ise,wt_ise);
         
}

kernel void astc(read_only image2d_t inputImage, __global uint4* astc_arr,
    __global PartInfo* global_parts, __global uint* errs) {
    int uWidth = get_global_size(0);
    int uHeight = get_global_size(1);
    const int2 local_id = (int2) (get_local_id(0), get_local_id(1));
    if(local_id.x == 0 && local_id.y == 0){
        const int2 pos = (int2)(get_global_id(0), get_global_id(1));
        const int2 group = (int2)(get_group_id(0), get_group_id(1));
        int BlockNumX = (uWidth + DIM - 1)/DIM;
        int BlockNumY = (uHeight + DIM - 1)/DIM;

        int BlockID = group.y * BlockNumX + group.x;
        float4 texels[BLOCK_SIZE];
        float4 texel_mean = (float4)(0);
        for(int i = 0; i < DIM; ++i){
            for(int j = 0; j < DIM; ++j){
                int2 pixelPos = pos + (int2)(j,i);
                if(pixelPos.x > uWidth || pixelPos.y > uHeight){
                    texels[i*DIM + j] = (float4)(255.0f);
                    continue;
                }
                float4 texel = read_imagef(inputImage, pixelPos);
                texels[i*DIM + j] = texel * 255.0f;
                texel_mean += texel * 255.0f;
            }
        }
        texel_mean = texel_mean / (float)(BLOCK_SIZE);
        astc_arr[BlockID] = encode_block(texels,texel_mean,BlockID,global_parts,errs);    
    }
}
)";

size_t FileIOGetSize(FILE *fileIn)
{
    size_t ret = 0;
    if(!fileIn){
        return 0;
    }
    fseek(fileIn, 0, SEEK_END);
    ret = ftell(fileIn);
    fseek(fileIn, 0, SEEK_SET);
    return ret;
}

static int GetCores()
{
    return sysconf(_SC_NPROCESSORS_CONF);
}
int32_t TidAffinityBindToCpu(unsigned int cpuID)
{
    int cores = GetCores();
    if(static_cast<int>(cpuID) >= cores) {
        printf("your set cpuID[%d] is beyond the cores[%d],exit...", cpuID, cores);
        return -1;
    }
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(cpuID, &mask);
    if(sched_setaffinity(getpid(),sizeof(mask), &mask) == -1){
        printf("counld not get thread affinity !\n");
        return -1;
    }
    return 0;
}

std::shared_ptr<ImageCompressor> ImageCompressor::instance_ = nullptr;
std::mutex ImageCompressor::instanceMutex_;
std::shared_ptr<ImageCompressor> ImageCompressor::GetInstance()
{
    if(instance_ == nullptr){
        std::lock_guard<std::mutex> lock(instanceMutex_);
        if(instance_ == nullptr){
            instance_.reset(new ImageCompressor());
            instance_->Init();
        }
    }
    return instance_;
}
void ImageCompressor::Init()
{
    switch_  = true;
    if (switch_){
        clOk_ = OHOS::InitOpenCL();
        if(!clOk_){
            HiLog::Error(LABEL,"mxs InitOpenCL error !");
            printf("mxs InitOpenCL error !\n");
        }
        InitPartition();
    }
}
bool ImageCompressor::CanCompress()
{
#ifdef UPLOAD_GPU_DISABLED
    return false;
#else
    if(switch_ && clOk_){
        return true;
    }
    return false;
#endif
}

cl_program ImageCompressor::LoadShader(cl_context context)
{
    cl_int err;
    sourceSize = strlen(g_programSource) + 1;
    cl_program p = clCreateProgramWithSource(context, 1, &g_programSource, &sourceSize, &err);
    if (err || (!p)) {
        HiLog::Error(LABEL, "mxs clCreateProgramWithSource error !");
        printf("clCreateProgramWithSource error %d \n",err);
        return nullptr;
    }
    return p;
}

char *ImageCompressor::ReadSourceCode(const char *fileName)
{
    size_t size = 0;
    char *content = nullptr;
    std::fstream f(fileName, (std::fstream::in | std::fstream::binary));
    if (f.is_open()) {
        size_t sizeFile;
        f.seekg(0,std::fstream::end);
        size = sizeFile = static_cast<size_t>(f.tellg());
        f.seekg(0, std::fstream::beg);

        content  = (char *)malloc(sizeof(char) * (size + 1));
        if (content == nullptr) {
            f.close();
            return content;
        }

        f.read(content, sizeFile);
        f.close();
        content[size] = '\0';
    }
    sourceSize = strlen(content);

    return content;
}
bool ImageCompressor::CreateKernel()
{
    if (!context_ || !kernel_){
        cl_int err;
        cl_platform_id platform_id;
        cl_device_id device_id;
        clGetPlatformIDs(1,&platform_id, NULL);
        if (!platform_id) {
            HiLog::Error(LABEL, "mxs clGetPlatformIDs err! \n");
            return false;
        }
        clGetDeviceIDs(platform_id,CL_DEVICE_TYPE_GPU, 1, &device_id,NULL);
        if (!device_id) {
            HiLog::Error(LABEL, "mxs clGetDeviceIDs error! \n");
            return false;
        }
        context_ = clCreateContext(0, 1, &device_id, NULL, NULL, &err);
        if (!context_) {
            HiLog::Error(LABEL, "mxs clCreateContext error %{public}d !", err);
        }
        queue_ = clCreateCommandQueueWithProperties(context_, device_id, 0, &err);
        if (!queue_) {
            HiLog::Error(LABEL, "mxs clCreateCommandQueueWithProperties error %{public}d ! \n", err);
        }
        cl_program program = LoadShader(context_);
        if (!program) {
            HiLog::Error(LABEL, "mxs LoadShaderBin error ! \n");
        }
        clBuildProgram(program, 1, &device_id, compileOption_.c_str(),NULL,NULL);
        kernel_ = clCreateKernel(program, "astc", &err);
        if (!kernel_) {
            HiLog::Error(LABEL, "mxs clCreateKernel error %{public}d !", err);
        }
        clReleaseProgram(program);
    }
    if (!context_ || !kernel_ || !queue_){
        ReleaseResource();
        HiLog::Error(LABEL, "build opencl program failed \n");
        clOk_ = false;
        return false;
    }
    refCount_++;
    return true;
}

void ImageCompressor::ReleaseResource()
{
    clReleaseKernel(kernel_);
    kernel_ = NULL;
    clReleaseCommandQueue(queue_);
    queue_ = NULL;
    clReleaseContext(context_);
    context_ = NULL;
    instance_ = nullptr;   
}

void ImageCompressor::GenAstcHeader(uint8_t *buffer, uint8_t blockX, uint8_t blockY, uint32_t dimX, uint32_t dimY)
{
    uint8_t *headInfo = (uint8_t *)buffer;
    *headInfo++ = MAGIC_FILE_CONSTANT & BYTES_MASK;
    *headInfo++ = (MAGIC_FILE_CONSTANT >> BIT_SHIFT_8BITS) & BYTES_MASK;
    *headInfo++ = (MAGIC_FILE_CONSTANT >> BIT_SHIFT_16BITS) & BYTES_MASK;
    *headInfo++ = (MAGIC_FILE_CONSTANT >> BIT_SHIFT_24BITS) & BYTES_MASK;
    *headInfo++ = static_cast<uint8_t>(blockX);
    *headInfo++ = static_cast<uint8_t>(blockY);
    *headInfo++ = 1;
    *headInfo++ = dimX & BYTES_MASK;
    *headInfo++ = (dimX >> BIT_SHIFT_8BITS )& BYTES_MASK;
    *headInfo++ = (dimX >> BIT_SHIFT_16BITS )& BYTES_MASK;
    *headInfo++ = dimY & BYTES_MASK;
    *headInfo++ = (dimY >> BIT_SHIFT_8BITS )& BYTES_MASK;
    *headInfo++ = (dimY >> BIT_SHIFT_16BITS )& BYTES_MASK;
    *headInfo++ = 1 & BYTES_MASK;
    *headInfo++ = (1 >> BIT_SHIFT_8BITS ) & BYTES_MASK;
    *headInfo++ = (1 >> BIT_SHIFT_16BITS ) & BYTES_MASK;
}

bool ImageCompressor::TextureEncodeCL(uint8_t *data, int32_t strideIn, int32_t width, int32_t height, uint8_t *buffer)
{
    int32_t stride = strideIn >> STRIDE_RGBA_LOG2;
    std::lock_guard<std::mutex> lock(instanceMutex_);
    if (!clOk_) {
        HiLog::Error(LABEL, "TextureEncodeCL CreateKernel error");
        return false;
    }
    if (width <= 0 || height <= 0 || !buffer || !data || (stride < width)) {
        HiLog::Error(LABEL, "TextureEncodeCL input parameters error");
        return  false;
    }
    GenAstcHeader(buffer, DIM, DIM, width, height);
    cl_int err;
    int32_t blockX = (width + DIM - 1) / DIM;
    int32_t blockY = (height + DIM - 1) / DIM;
    int32_t numBlocks = blockX * blockY;
    size_t local[] = {DIM, DIM};

    size_t global[GLOBAL_WH_NUM_CL];
    global[0] = (width % local[0] == 0 ? width : (width + local[0] - width % local[0]));
    global[1] = (height % local[1] == 0 ? height : (height + local[1] - height % local[1]));

    size_t astc_size = numBlocks * DIM * DIM;

    cl_image_format image_format = { CL_RGBA, CL_UNORM_INT8 };
    cl_image_desc desc = { CL_MEM_OBJECT_IMAGE2D, stride, height };
    cl_mem inputImage = 
        clCreateImage(context_, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, &image_format, &desc, data, &err);
    cl_mem astcResult = clCreateBuffer(context_, CL_MEM_ALLOC_HOST_PTR, astc_size, NULL, &err);
    cl_mem partInfos = 
        clCreateBuffer(context_, CL_MEM_COPY_HOST_PTR,sizeof(PartInfo) * parts_.size(), &parts_[0], &err);
    
    uint32_t *blockErrs = new uint32_t[numBlocks]{ 0 };
    cl_mem clErrs = clCreateBuffer(context_,CL_MEM_USE_HOST_PTR, sizeof(uint32_t) * numBlocks, blockErrs, &err);

    int32_t kernelId = 0;
    err |= clSetKernelArg(kernel_, kernelId++ ,sizeof(cl_mem), &inputImage);
    err |= clSetKernelArg(kernel_, kernelId++ ,sizeof(cl_mem), &astcResult);
    err |= clSetKernelArg(kernel_, kernelId++ ,sizeof(cl_mem), &partInfos);
    err |= clSetKernelArg(kernel_, kernelId++ ,sizeof(cl_mem), &clErrs);

    err = clEnqueueNDRangeKernel(queue_, kernel_, GLOBAL_WH_NUM_CL, NULL, global, local, 0, NULL, NULL);

    clFinish(queue_);

    uint32_t max_val = 0,sum_val = 0;
    err = clEnqueueReadBuffer(queue_, clErrs, CL_TRUE, 0, sizeof(uint32_t) * numBlocks, blockErrs, 0, NULL,NULL);
    for (int32_t i = 0; i < numBlocks; i++) {
        sum_val += blockErrs[i];
        max_val = fmax(max_val, blockErrs[i]);
    }

    clReleaseMemObject(inputImage);
    clReleaseMemObject(partInfos);
    clReleaseMemObject(clErrs);
    delete[] blockErrs;
    
    clEnqueueReadBuffer(queue_, astcResult, CL_TRUE, 0, astc_size, buffer + TEXTURE_HEAD_BYTES, 0, NULL,NULL);
    clReleaseMemObject(astcResult);

    return true;
}

std::function<void()> ImageCompressor::ScheduleReleaseTask()
{
    std::function<void()> task = [this]() {
        if (refCount_ > 0 && clOk_) {
            refCount_--;
            if (refCount_ <= 0) {
                this->ReleaseResource();

                std::ofstream saveFile(recordsPath_);
                if (!saveFile.is_open()) {
                    return ;
                } 
                std::lock_guard<std::mutex> mLock(recordsMutex_);
                for (auto s : failedRecords_) {
                    saveFile <<s << "\n";
                }
                saveFile.close();
            }
        }
    };
    return task;
}




static uint32_t Hash52(uint32_t seed)
{
    seed ^= seed >> HASH_MAGIC_SEED_BIT;
    seed *= HASH_MAGIC_SEED;
    seed ^= seed >> HASH_SEED_1;
    seed += seed << HASH_SEED_2;
    seed ^= seed >> HASH_SEED_3;
    seed ^= seed >> HASH_SEED_4;
    seed ^= seed << HASH_SEED_5;
    seed ^= seed >> HASH_SEED_6;
    return seed;    
}

#define SEED_MAGIC_NUM_01 (4)
#define SEED_MAGIC_NUM_02 (12)
#define SEED_MAGIC_NUM_03 (20)
#define SEED_MAGIC_NUM_04 (28)
#define SEED_MAGIC_NUM_05 (18)
#define SEED_MAGIC_NUM_06 (22)
#define SEED_MAGIC_NUM_07 (26)
#define SEED_MAGIC_NUM_08 (30)
#define SEED_MAGIC_NUM_09 (2)

#define SEED_MAGIC_2 (2)
#define SEED_MAGIC_3 (3)
#define SEED_MAGIC_4 (4)
#define SEED_MAGIC_5 (5)
#define SEED_MAGIC_6 (6)
#define SEED_MAGIC_7 (7)
#define SEED_MAGIC_8 (8)
#define SEED_MAGIC_9 (9)
#define SEED_MAGIC_10 (10)
#define SEED_MAGIC_11 (11)
#define SEED_MAGIC_14 (14)
#define MASK_4TH_BIT (0x10)
#define MASK_LOW7BIT (0x3F)
#define PARTITION_COUNT_1 (1)
#define PARTITION_COUNT_2 (2)
#define PARTITION_COUNT_3 (3)
#define PARTITION_COUNT_4 (4)
#define SEED_NUM (12)

static void CalSeedNum(uint8_t seedn[SEED_NUM], uint32_t num)
{
    uint8_t *seed = seedn;
    *seed++ = num & HALF_BYTES_MASK;
    *seed++ = (num >> SEED_MAGIC_NUM_01) & HALF_BYTES_MASK;
    *seed++ = (num >> BIT_SHIFT_8BITS) & HALF_BYTES_MASK;
    *seed++ = (num >> SEED_MAGIC_NUM_02) & HALF_BYTES_MASK;
    *seed++ = (num >> BIT_SHIFT_16BITS) & HALF_BYTES_MASK;
    *seed++ = (num >> SEED_MAGIC_NUM_03) & HALF_BYTES_MASK;
    *seed++ = (num >> BIT_SHIFT_24BITS) & HALF_BYTES_MASK;
    *seed++ = (num >> SEED_MAGIC_NUM_04) & HALF_BYTES_MASK;
    *seed++ = (num >> SEED_MAGIC_NUM_05) & HALF_BYTES_MASK;
    *seed++ = (num >> SEED_MAGIC_NUM_06) & HALF_BYTES_MASK;
    *seed++ = (num >> SEED_MAGIC_NUM_07) & HALF_BYTES_MASK;
    *seed++ = ((num >> SEED_MAGIC_NUM_08) | (num << SEED_MAGIC_NUM_09)) & HALF_BYTES_MASK;

    for (int i=0; i < SEED_NUM; i++) {
        seedn[i] *= seedn[i];
    }
}

uint8_t CalPartition(int32_t partitionCount, int32_t a, int32_t b, int32_t c, int32_t d)
{
    a &= MASK_LOW7BIT;
    b &= MASK_LOW7BIT;
    c &= MASK_LOW7BIT;
    d &= MASK_LOW7BIT;

    if (partitionCount <= PARTITION_COUNT_3) {
        d = 0;
    }
    if (partitionCount <= PARTITION_COUNT_2) {
        c = 0;
    } 
    if (partitionCount <= PARTITION_COUNT_1) {
        b = 0;
    }
    uint8_t partition;
    if (a >= b && a >= c &&  a >= d) {
        partition = 0;
    } else if (b >= c &&  b >= d) {
        partition = PARTITION_COUNT_1;
    } else if (c >= d) {
        partition = PARTITION_COUNT_2;
    } else {
        partition = PARTITION_COUNT_3;
    }
    return partition;
}

static uint8_t SelectPartition(int32_t seed, int32_t x, int32_t y, int32_t partitionCount, bool smallBlock)
{
    if (smallBlock) {
        x <<= 1;
        y <<= 1;
    }
    seed += (partitionCount - 1) <<10;
    uint32_t num = Hash52(seed);
    uint8_t seedn[SEED_NUM];
    CalSeedNum(seedn, num);
    int32_t sh1, sh2;
    if (seed & 1) {
        sh1 = (seed & SEED_MAGIC_2 ? SEED_MAGIC_4 : SEED_MAGIC_5);
        sh2 = (partitionCount == PARTITION_COUNT_3 ? SEED_MAGIC_6 : SEED_MAGIC_5);
    } else {
        sh1 = (partitionCount == PARTITION_COUNT_3 ? SEED_MAGIC_6 : SEED_MAGIC_5);
        sh2 = (seed & SEED_MAGIC_2 ? SEED_MAGIC_4 : SEED_MAGIC_5);
    }
    int32_t sh3 = (seed & MASK_4TH_BIT) ? sh1 : sh2;
    int i;
    for (i = 0; i < SEED_MAGIC_8; i += SEED_MAGIC_2) {
        seedn[i] >>= sh1;
        seedn[i + 1] >>= sh2;
    }
    for (; i <SEED_NUM; i++) {
        seedn[i] >>= sh3;
    }
    int32_t a = seedn[0] * x + seedn[1] * y + (num >> SEED_MAGIC_14);
    int32_t b = seedn[SEED_MAGIC_2] * x + seedn[SEED_MAGIC_3] * y + (num >> SEED_MAGIC_10);
    int32_t c = seedn[SEED_MAGIC_4] * x + seedn[SEED_MAGIC_5] * y + (num >> SEED_MAGIC_6);
    int32_t d = seedn[SEED_MAGIC_6] * x + seedn[SEED_MAGIC_7] * y + (num >> SEED_MAGIC_2);
        return CalPartition(partitionCount, a, b, c, d);
}

bool ImageCompressor::InitPartitionInfo(PartInfo *partInfos, int32_t part_index, int32_t part_count)
{
    int32_t texIdx = 0;
    int32_t counts[PARTITION_COUNT_4] = {0};
    for (int32_t y = 0; y <DIM; y++){
        for (int32_t x = 0; x < DIM; x++) {
            int32_t part = SelectPartition(part_index, x, y, part_count, true);
            partInfos->bitmaps[part] |= 1u << texIdx;
            counts[part]++;
            texIdx++;
        }
    }
    int32_t realPartCount = 0;
    if (counts[0] == 0) {
        realPartCount = 0;
    } else if (counts[1] == 0) {
        realPartCount = 1;
    } else if (counts[PARTITION_COUNT_2] == 0) {
        realPartCount = PARTITION_COUNT_2;
    } else if (counts[PARTITION_COUNT_3] == 0) {
        realPartCount = PARTITION_COUNT_3;
    } else {
        realPartCount = PARTITION_COUNT_4;
    }
    if (realPartCount == part_count) {
        return true;
    }
    return false;
}

void ImageCompressor::InitPartition()
{
    parts_.clear();
    int32_t arrSize = sizeof(partitions_) / sizeof(partitions_[0]);
    for (int32_t i = 0; i < arrSize; i++) {
        PartInfo p = {};
        if (InitPartitionInfo(&p, partitions_[i], PARTITION_COUNT_2)) {
            p.partid = partitions_[i];
            parts_.push_back(p);
        }
    }
    compileOption_ = "-D PARTITION_SERACH_MAX=" + std::to_string(parts_.size());
}
} // namespace Media
} // namespace OHOS